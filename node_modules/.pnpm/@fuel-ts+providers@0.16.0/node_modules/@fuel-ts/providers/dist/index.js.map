{"version":3,"sources":["../src/index.ts","../src/coin-quantity.ts","../src/__generated__/operations.ts","../src/provider.ts","../src/transaction-request/input.ts","../src/transaction-request/output.ts","../src/transaction-request/transaction-request.ts","../src/util.ts","../src/transaction-request/storage-slot.ts","../src/transaction-request/witness.ts","../src/transaction-response/transaction-response.ts","../src/LogReader.ts"],"sourcesContent":["/// <reference types=\"graphql\" />\n\nexport * from './coin-quantity';\nexport * from './coin';\nexport * from './provider';\nexport { default as Provider } from './provider';\nexport * from './transaction-request';\nexport * from './transaction-response';\nexport * from './util';\nexport { default as LogReader } from './LogReader';\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify } from '@ethersproject/bytes';\nimport { NativeAssetId } from '@fuel-ts/constants';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\n\nexport type CoinQuantityLike =\n  | [amount: BigNumberish, assetId?: BytesLike]\n  | { amount: BigNumberish; assetId?: BytesLike };\nexport type CoinQuantity = { amount: BN; assetId: string };\n\nexport const coinQuantityfy = (coinQuantityLike: CoinQuantityLike): CoinQuantity => {\n  let assetId;\n  let amount;\n  if (Array.isArray(coinQuantityLike)) {\n    amount = coinQuantityLike[0];\n    assetId = coinQuantityLike[1] ?? NativeAssetId;\n  } else {\n    amount = coinQuantityLike.amount;\n    assetId = coinQuantityLike.assetId ?? NativeAssetId;\n  }\n\n  return {\n    assetId: hexlify(assetId),\n    amount: bn(amount),\n  };\n};\n","import type { GraphQLClient } from 'graphql-request';\nimport type * as Dom from 'graphql-request/dist/types.dom';\nimport gql from 'graphql-tag';\n\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  Address: string;\n  AssetId: string;\n  BlockId: string;\n  Bytes32: string;\n  ContractId: string;\n  /**\n   * Implement the DateTime<Utc> scalar\n   *\n   * The input/output is a string in RFC3339 format.\n   */\n  DateTime: string;\n  HexString: string;\n  MessageId: any;\n  Salt: string;\n  TransactionId: string;\n  TxPointer: any;\n  U64: string;\n  UtxoId: string;\n};\n\nexport type GqlBalance = {\n  __typename: 'Balance';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  owner: Scalars['Address'];\n};\n\nexport type GqlBalanceConnection = {\n  __typename: 'BalanceConnection';\n  /** A list of edges. */\n  edges: Array<GqlBalanceEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlBalance>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlBalanceEdge = {\n  __typename: 'BalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlBalance;\n};\n\nexport type GqlBalanceFilterInput = {\n  /** Filter coins based on the `owner` field */\n  owner: Scalars['Address'];\n};\n\nexport type GqlBlock = {\n  __typename: 'Block';\n  height: Scalars['U64'];\n  id: Scalars['BlockId'];\n  producer: Scalars['Address'];\n  time: Scalars['DateTime'];\n  transactions: Array<GqlTransaction>;\n};\n\nexport type GqlBlockConnection = {\n  __typename: 'BlockConnection';\n  /** A list of edges. */\n  edges: Array<GqlBlockEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlBlock>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlBlockEdge = {\n  __typename: 'BlockEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlBlock;\n};\n\nexport type GqlBreakpoint = {\n  contract: Scalars['ContractId'];\n  pc: Scalars['U64'];\n};\n\nexport type GqlChainInfo = {\n  __typename: 'ChainInfo';\n  baseChainHeight: Scalars['U64'];\n  consensusParameters: GqlConsensusParameters;\n  latestBlock: GqlBlock;\n  name: Scalars['String'];\n  peerCount: Scalars['Int'];\n};\n\nexport type GqlChangeOutput = {\n  __typename: 'ChangeOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport type GqlCoin = {\n  __typename: 'Coin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  blockCreated: Scalars['U64'];\n  maturity: Scalars['U64'];\n  owner: Scalars['Address'];\n  status: GqlCoinStatus;\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlCoinConnection = {\n  __typename: 'CoinConnection';\n  /** A list of edges. */\n  edges: Array<GqlCoinEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlCoin>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlCoinEdge = {\n  __typename: 'CoinEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlCoin;\n};\n\nexport type GqlCoinFilterInput = {\n  /** Asset ID of the coins */\n  assetId?: InputMaybe<Scalars['AssetId']>;\n  /** Address of the owner */\n  owner: Scalars['Address'];\n};\n\nexport type GqlCoinOutput = {\n  __typename: 'CoinOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport enum GqlCoinStatus {\n  Spent = 'SPENT',\n  Unspent = 'UNSPENT',\n}\n\nexport type GqlConsensusParameters = {\n  __typename: 'ConsensusParameters';\n  contractMaxSize: Scalars['U64'];\n  gasPerByte: Scalars['U64'];\n  gasPriceFactor: Scalars['U64'];\n  maxGasPerTx: Scalars['U64'];\n  maxInputs: Scalars['U64'];\n  maxMessageDataLength: Scalars['U64'];\n  maxOutputs: Scalars['U64'];\n  maxPredicateDataLength: Scalars['U64'];\n  maxPredicateLength: Scalars['U64'];\n  maxScriptDataLength: Scalars['U64'];\n  maxScriptLength: Scalars['U64'];\n  maxStorageSlots: Scalars['U64'];\n  maxWitnesses: Scalars['U64'];\n};\n\nexport type GqlContract = {\n  __typename: 'Contract';\n  bytecode: Scalars['HexString'];\n  id: Scalars['ContractId'];\n  salt: Scalars['Salt'];\n};\n\nexport type GqlContractBalance = {\n  __typename: 'ContractBalance';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlContractBalanceConnection = {\n  __typename: 'ContractBalanceConnection';\n  /** A list of edges. */\n  edges: Array<GqlContractBalanceEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlContractBalance>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlContractBalanceEdge = {\n  __typename: 'ContractBalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlContractBalance;\n};\n\nexport type GqlContractBalanceFilterInput = {\n  /** Filter assets based on the `contractId` field */\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlContractCreated = {\n  __typename: 'ContractCreated';\n  contract: GqlContract;\n  stateRoot: Scalars['Bytes32'];\n};\n\nexport type GqlContractOutput = {\n  __typename: 'ContractOutput';\n  balanceRoot: Scalars['Bytes32'];\n  inputIndex: Scalars['Int'];\n  stateRoot: Scalars['Bytes32'];\n};\n\nexport type GqlFailureStatus = {\n  __typename: 'FailureStatus';\n  block: GqlBlock;\n  programState?: Maybe<GqlProgramState>;\n  reason: Scalars['String'];\n  time: Scalars['DateTime'];\n};\n\nexport type GqlInput = GqlInputCoin | GqlInputContract | GqlInputMessage;\n\nexport type GqlInputCoin = {\n  __typename: 'InputCoin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  maturity: Scalars['U64'];\n  owner: Scalars['Address'];\n  predicate: Scalars['HexString'];\n  predicateData: Scalars['HexString'];\n  txPointer: Scalars['TxPointer'];\n  utxoId: Scalars['UtxoId'];\n  witnessIndex: Scalars['Int'];\n};\n\nexport type GqlInputContract = {\n  __typename: 'InputContract';\n  balanceRoot: Scalars['Bytes32'];\n  contract: GqlContract;\n  stateRoot: Scalars['Bytes32'];\n  txPointer: Scalars['TxPointer'];\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlInputMessage = {\n  __typename: 'InputMessage';\n  amount: Scalars['U64'];\n  data: Scalars['HexString'];\n  messageId: Scalars['MessageId'];\n  nonce: Scalars['U64'];\n  owner: Scalars['Address'];\n  predicate: Scalars['HexString'];\n  predicateData: Scalars['HexString'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n  witnessIndex: Scalars['Int'];\n};\n\nexport type GqlMessage = {\n  __typename: 'Message';\n  amount: Scalars['U64'];\n  daHeight: Scalars['U64'];\n  data: Array<Scalars['Int']>;\n  fuelBlockSpend?: Maybe<Scalars['U64']>;\n  nonce: Scalars['U64'];\n  owner: Scalars['Address'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n};\n\nexport type GqlMessageConnection = {\n  __typename: 'MessageConnection';\n  /** A list of edges. */\n  edges: Array<GqlMessageEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlMessage>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlMessageEdge = {\n  __typename: 'MessageEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlMessage;\n};\n\nexport type GqlMessageOutput = {\n  __typename: 'MessageOutput';\n  amount: Scalars['U64'];\n  recipient: Scalars['Address'];\n};\n\nexport type GqlMutation = {\n  __typename: 'Mutation';\n  continueTx: GqlRunResult;\n  /** Execute a dry-run of the transaction using a fork of current state, no changes are committed. */\n  dryRun: Array<GqlReceipt>;\n  endSession: Scalars['Boolean'];\n  execute: Scalars['Boolean'];\n  produceBlocks: Scalars['U64'];\n  reset: Scalars['Boolean'];\n  setBreakpoint: Scalars['Boolean'];\n  setSingleStepping: Scalars['Boolean'];\n  startSession: Scalars['ID'];\n  startTx: GqlRunResult;\n  /** Submits transaction to the txpool */\n  submit: GqlTransaction;\n};\n\nexport type GqlMutationContinueTxArgs = {\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationDryRunArgs = {\n  tx: Scalars['HexString'];\n  utxoValidation?: InputMaybe<Scalars['Boolean']>;\n};\n\nexport type GqlMutationEndSessionArgs = {\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationExecuteArgs = {\n  id: Scalars['ID'];\n  op: Scalars['String'];\n};\n\nexport type GqlMutationProduceBlocksArgs = {\n  blocksToProduce: Scalars['U64'];\n};\n\nexport type GqlMutationResetArgs = {\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationSetBreakpointArgs = {\n  breakpoint: GqlBreakpoint;\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationSetSingleSteppingArgs = {\n  enable: Scalars['Boolean'];\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationStartTxArgs = {\n  id: Scalars['ID'];\n  txJson: Scalars['String'];\n};\n\nexport type GqlMutationSubmitArgs = {\n  tx: Scalars['HexString'];\n};\n\nexport type GqlNodeInfo = {\n  __typename: 'NodeInfo';\n  maxDepth: Scalars['U64'];\n  maxTx: Scalars['U64'];\n  minGasPrice: Scalars['U64'];\n  nodeVersion: Scalars['String'];\n  predicates: Scalars['Boolean'];\n  utxoValidation: Scalars['Boolean'];\n  vmBacktrace: Scalars['Boolean'];\n};\n\nexport type GqlOutput =\n  | GqlChangeOutput\n  | GqlCoinOutput\n  | GqlContractCreated\n  | GqlContractOutput\n  | GqlMessageOutput\n  | GqlVariableOutput;\n\n/**\n * A separate `Breakpoint` type to be used as an output, as a single\n * type cannot act as both input and output type in async-graphql\n */\nexport type GqlOutputBreakpoint = {\n  __typename: 'OutputBreakpoint';\n  contract: Scalars['ContractId'];\n  pc: Scalars['U64'];\n};\n\n/** Information about pagination in a connection */\nexport type GqlPageInfo = {\n  __typename: 'PageInfo';\n  /** When paginating forwards, the cursor to continue. */\n  endCursor?: Maybe<Scalars['String']>;\n  /** When paginating forwards, are there more items? */\n  hasNextPage: Scalars['Boolean'];\n  /** When paginating backwards, are there more items? */\n  hasPreviousPage: Scalars['Boolean'];\n  /** When paginating backwards, the cursor to continue. */\n  startCursor?: Maybe<Scalars['String']>;\n};\n\nexport type GqlProgramState = {\n  __typename: 'ProgramState';\n  data: Scalars['HexString'];\n  returnType: GqlReturnType;\n};\n\nexport type GqlQuery = {\n  __typename: 'Query';\n  balance: GqlBalance;\n  balances: GqlBalanceConnection;\n  block?: Maybe<GqlBlock>;\n  blocks: GqlBlockConnection;\n  chain: GqlChainInfo;\n  coin?: Maybe<GqlCoin>;\n  coins: GqlCoinConnection;\n  /**\n   * For each `spend_query`, get some spendable coins (of asset specified by the query) owned by\n   * `owner` that add up at least the query amount. The returned coins (UTXOs) are actual coins\n   * that can be spent. The number of coins (UXTOs) is optimized to prevent dust accumulation.\n   * Max number of UTXOS and excluded UTXOS can also be specified.\n   */\n  coinsToSpend: Array<GqlCoin>;\n  contract?: Maybe<GqlContract>;\n  contractBalance: GqlContractBalance;\n  contractBalances: GqlContractBalanceConnection;\n  /** Returns true when the GraphQL API is serving requests. */\n  health: Scalars['Boolean'];\n  memory: Scalars['String'];\n  messages: GqlMessageConnection;\n  nodeInfo: GqlNodeInfo;\n  register: Scalars['U64'];\n  transaction?: Maybe<GqlTransaction>;\n  transactions: GqlTransactionConnection;\n  transactionsByOwner: GqlTransactionConnection;\n};\n\nexport type GqlQueryBalanceArgs = {\n  assetId: Scalars['AssetId'];\n  owner: Scalars['Address'];\n};\n\nexport type GqlQueryBalancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlBalanceFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryBlockArgs = {\n  height?: InputMaybe<Scalars['U64']>;\n  id?: InputMaybe<Scalars['BlockId']>;\n};\n\nexport type GqlQueryBlocksArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryCoinArgs = {\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlQueryCoinsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlCoinFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryCoinsToSpendArgs = {\n  excludedIds?: InputMaybe<Array<Scalars['UtxoId']>>;\n  maxInputs?: InputMaybe<Scalars['Int']>;\n  owner: Scalars['Address'];\n  spendQuery: Array<GqlSpendQueryElementInput>;\n};\n\nexport type GqlQueryContractArgs = {\n  id: Scalars['ContractId'];\n};\n\nexport type GqlQueryContractBalanceArgs = {\n  asset: Scalars['AssetId'];\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlQueryContractBalancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlContractBalanceFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryMemoryArgs = {\n  id: Scalars['ID'];\n  size: Scalars['U64'];\n  start: Scalars['U64'];\n};\n\nexport type GqlQueryMessagesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  owner?: InputMaybe<Scalars['Address']>;\n};\n\nexport type GqlQueryRegisterArgs = {\n  id: Scalars['ID'];\n  register: Scalars['U64'];\n};\n\nexport type GqlQueryTransactionArgs = {\n  id: Scalars['TransactionId'];\n};\n\nexport type GqlQueryTransactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryTransactionsByOwnerArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  owner: Scalars['Address'];\n};\n\nexport type GqlReceipt = {\n  __typename: 'Receipt';\n  amount?: Maybe<Scalars['U64']>;\n  assetId?: Maybe<Scalars['AssetId']>;\n  contract?: Maybe<GqlContract>;\n  data?: Maybe<Scalars['HexString']>;\n  digest?: Maybe<Scalars['Bytes32']>;\n  gas?: Maybe<Scalars['U64']>;\n  gasUsed?: Maybe<Scalars['U64']>;\n  is?: Maybe<Scalars['U64']>;\n  len?: Maybe<Scalars['U64']>;\n  messageId?: Maybe<Scalars['MessageId']>;\n  nonce?: Maybe<Scalars['Bytes32']>;\n  param1?: Maybe<Scalars['U64']>;\n  param2?: Maybe<Scalars['U64']>;\n  pc?: Maybe<Scalars['U64']>;\n  ptr?: Maybe<Scalars['U64']>;\n  ra?: Maybe<Scalars['U64']>;\n  rawPayload: Scalars['HexString'];\n  rb?: Maybe<Scalars['U64']>;\n  rc?: Maybe<Scalars['U64']>;\n  rd?: Maybe<Scalars['U64']>;\n  reason?: Maybe<Scalars['U64']>;\n  receiptType: GqlReceiptType;\n  recipient?: Maybe<Scalars['Address']>;\n  result?: Maybe<Scalars['U64']>;\n  sender?: Maybe<Scalars['Address']>;\n  to?: Maybe<GqlContract>;\n  toAddress?: Maybe<Scalars['Address']>;\n  val?: Maybe<Scalars['U64']>;\n};\n\nexport enum GqlReceiptType {\n  Call = 'CALL',\n  Log = 'LOG',\n  LogData = 'LOG_DATA',\n  MessageOut = 'MESSAGE_OUT',\n  Panic = 'PANIC',\n  Return = 'RETURN',\n  ReturnData = 'RETURN_DATA',\n  Revert = 'REVERT',\n  ScriptResult = 'SCRIPT_RESULT',\n  Transfer = 'TRANSFER',\n  TransferOut = 'TRANSFER_OUT',\n}\n\nexport enum GqlReturnType {\n  Return = 'RETURN',\n  ReturnData = 'RETURN_DATA',\n  Revert = 'REVERT',\n}\n\nexport type GqlRunResult = {\n  __typename: 'RunResult';\n  breakpoint?: Maybe<GqlOutputBreakpoint>;\n  jsonReceipts: Array<Scalars['String']>;\n  state: GqlRunState;\n};\n\nexport enum GqlRunState {\n  /** Stopped on a breakpoint */\n  Breakpoint = 'BREAKPOINT',\n  /** All breakpoints have been processed, and the program has terminated */\n  Completed = 'COMPLETED',\n}\n\nexport type GqlSpendQueryElementInput = {\n  /** Target amount for the query */\n  amount: Scalars['U64'];\n  /** Asset ID of the coins */\n  assetId: Scalars['AssetId'];\n};\n\nexport type GqlSubmittedStatus = {\n  __typename: 'SubmittedStatus';\n  time: Scalars['DateTime'];\n};\n\nexport type GqlSuccessStatus = {\n  __typename: 'SuccessStatus';\n  block: GqlBlock;\n  programState: GqlProgramState;\n  time: Scalars['DateTime'];\n};\n\nexport type GqlTransaction = {\n  __typename: 'Transaction';\n  bytecodeLength?: Maybe<Scalars['U64']>;\n  bytecodeWitnessIndex?: Maybe<Scalars['Int']>;\n  gasLimit: Scalars['U64'];\n  gasPrice: Scalars['U64'];\n  id: Scalars['TransactionId'];\n  inputAssetIds: Array<Scalars['AssetId']>;\n  inputContracts: Array<GqlContract>;\n  inputs: Array<GqlInput>;\n  isScript: Scalars['Boolean'];\n  maturity: Scalars['U64'];\n  outputs: Array<GqlOutput>;\n  /** Return the transaction bytes using canonical encoding */\n  rawPayload: Scalars['HexString'];\n  receipts?: Maybe<Array<GqlReceipt>>;\n  receiptsRoot?: Maybe<Scalars['Bytes32']>;\n  salt?: Maybe<Scalars['Salt']>;\n  script?: Maybe<Scalars['HexString']>;\n  scriptData?: Maybe<Scalars['HexString']>;\n  status?: Maybe<GqlTransactionStatus>;\n  storageSlots?: Maybe<Array<Scalars['HexString']>>;\n  witnesses: Array<Scalars['HexString']>;\n};\n\nexport type GqlTransactionConnection = {\n  __typename: 'TransactionConnection';\n  /** A list of edges. */\n  edges: Array<GqlTransactionEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlTransaction>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlTransactionEdge = {\n  __typename: 'TransactionEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlTransaction;\n};\n\nexport type GqlTransactionStatus = GqlFailureStatus | GqlSubmittedStatus | GqlSuccessStatus;\n\nexport type GqlVariableOutput = {\n  __typename: 'VariableOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport type GqlTransactionFragmentFragment = {\n  __typename: 'Transaction';\n  id: string;\n  rawPayload: string;\n  status?:\n    | {\n        __typename: 'FailureStatus';\n        time: string;\n        reason: string;\n        type: 'FailureStatus';\n        block: { __typename: 'Block'; id: string };\n      }\n    | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n    | {\n        __typename: 'SuccessStatus';\n        time: string;\n        type: 'SuccessStatus';\n        block: { __typename: 'Block'; id: string };\n        programState: { __typename: 'ProgramState'; returnType: GqlReturnType; data: string };\n      }\n    | null;\n};\n\nexport type GqlReceiptFragmentFragment = {\n  __typename: 'Receipt';\n  data?: string | null;\n  rawPayload: string;\n};\n\nexport type GqlBlockFragmentFragment = {\n  __typename: 'Block';\n  id: string;\n  height: string;\n  producer: string;\n  time: string;\n  transactions: Array<{ __typename: 'Transaction'; id: string }>;\n};\n\nexport type GqlCoinFragmentFragment = {\n  __typename: 'Coin';\n  utxoId: string;\n  owner: string;\n  amount: string;\n  assetId: string;\n  maturity: string;\n  status: GqlCoinStatus;\n  blockCreated: string;\n};\n\nexport type GqlBalanceFragmentFragment = {\n  __typename: 'Balance';\n  owner: string;\n  amount: string;\n  assetId: string;\n};\n\nexport type GqlChainInfoFragmentFragment = {\n  __typename: 'ChainInfo';\n  name: string;\n  baseChainHeight: string;\n  peerCount: number;\n  consensusParameters: {\n    __typename: 'ConsensusParameters';\n    gasPriceFactor: string;\n    maxGasPerTx: string;\n    maxScriptLength: string;\n  };\n  latestBlock: {\n    __typename: 'Block';\n    id: string;\n    height: string;\n    producer: string;\n    time: string;\n    transactions: Array<{ __typename: 'Transaction'; id: string }>;\n  };\n};\n\nexport type GqlGetVersionQueryVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlGetVersionQuery = {\n  __typename: 'Query';\n  nodeInfo: { __typename: 'NodeInfo'; nodeVersion: string };\n};\n\nexport type GqlGetInfoQueryVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlGetInfoQuery = {\n  __typename: 'Query';\n  nodeInfo: { __typename: 'NodeInfo'; nodeVersion: string; minGasPrice: string };\n};\n\nexport type GqlGetChainQueryVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlGetChainQuery = {\n  __typename: 'Query';\n  chain: {\n    __typename: 'ChainInfo';\n    name: string;\n    baseChainHeight: string;\n    peerCount: number;\n    consensusParameters: {\n      __typename: 'ConsensusParameters';\n      gasPriceFactor: string;\n      maxGasPerTx: string;\n      maxScriptLength: string;\n    };\n    latestBlock: {\n      __typename: 'Block';\n      id: string;\n      height: string;\n      producer: string;\n      time: string;\n      transactions: Array<{ __typename: 'Transaction'; id: string }>;\n    };\n  };\n};\n\nexport type GqlGetTransactionQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\nexport type GqlGetTransactionQuery = {\n  __typename: 'Query';\n  transaction?: {\n    __typename: 'Transaction';\n    id: string;\n    rawPayload: string;\n    status?:\n      | {\n          __typename: 'FailureStatus';\n          time: string;\n          reason: string;\n          type: 'FailureStatus';\n          block: { __typename: 'Block'; id: string };\n        }\n      | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n      | {\n          __typename: 'SuccessStatus';\n          time: string;\n          type: 'SuccessStatus';\n          block: { __typename: 'Block'; id: string };\n          programState: { __typename: 'ProgramState'; returnType: GqlReturnType; data: string };\n        }\n      | null;\n  } | null;\n};\n\nexport type GqlGetTransactionWithReceiptsQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\nexport type GqlGetTransactionWithReceiptsQuery = {\n  __typename: 'Query';\n  transaction?: {\n    __typename: 'Transaction';\n    id: string;\n    rawPayload: string;\n    receipts?: Array<{ __typename: 'Receipt'; data?: string | null; rawPayload: string }> | null;\n    status?:\n      | {\n          __typename: 'FailureStatus';\n          time: string;\n          reason: string;\n          type: 'FailureStatus';\n          block: { __typename: 'Block'; id: string };\n        }\n      | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n      | {\n          __typename: 'SuccessStatus';\n          time: string;\n          type: 'SuccessStatus';\n          block: { __typename: 'Block'; id: string };\n          programState: { __typename: 'ProgramState'; returnType: GqlReturnType; data: string };\n        }\n      | null;\n  } | null;\n};\n\nexport type GqlGetTransactionsQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetTransactionsQuery = {\n  __typename: 'Query';\n  transactions: {\n    __typename: 'TransactionConnection';\n    edges: Array<{\n      __typename: 'TransactionEdge';\n      node: {\n        __typename: 'Transaction';\n        id: string;\n        rawPayload: string;\n        status?:\n          | {\n              __typename: 'FailureStatus';\n              time: string;\n              reason: string;\n              type: 'FailureStatus';\n              block: { __typename: 'Block'; id: string };\n            }\n          | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n          | {\n              __typename: 'SuccessStatus';\n              time: string;\n              type: 'SuccessStatus';\n              block: { __typename: 'Block'; id: string };\n              programState: { __typename: 'ProgramState'; returnType: GqlReturnType; data: string };\n            }\n          | null;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetTransactionsByOwnerQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetTransactionsByOwnerQuery = {\n  __typename: 'Query';\n  transactionsByOwner: {\n    __typename: 'TransactionConnection';\n    edges: Array<{\n      __typename: 'TransactionEdge';\n      node: {\n        __typename: 'Transaction';\n        id: string;\n        rawPayload: string;\n        status?:\n          | {\n              __typename: 'FailureStatus';\n              time: string;\n              reason: string;\n              type: 'FailureStatus';\n              block: { __typename: 'Block'; id: string };\n            }\n          | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n          | {\n              __typename: 'SuccessStatus';\n              time: string;\n              type: 'SuccessStatus';\n              block: { __typename: 'Block'; id: string };\n              programState: { __typename: 'ProgramState'; returnType: GqlReturnType; data: string };\n            }\n          | null;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetBlockQueryVariables = Exact<{\n  blockId?: InputMaybe<Scalars['BlockId']>;\n  blockHeight?: InputMaybe<Scalars['U64']>;\n}>;\n\nexport type GqlGetBlockQuery = {\n  __typename: 'Query';\n  block?: {\n    __typename: 'Block';\n    id: string;\n    height: string;\n    producer: string;\n    time: string;\n    transactions: Array<{ __typename: 'Transaction'; id: string }>;\n  } | null;\n};\n\nexport type GqlGetBlockWithTransactionsQueryVariables = Exact<{\n  blockId?: InputMaybe<Scalars['BlockId']>;\n  blockHeight?: InputMaybe<Scalars['U64']>;\n}>;\n\nexport type GqlGetBlockWithTransactionsQuery = {\n  __typename: 'Query';\n  block?: {\n    __typename: 'Block';\n    id: string;\n    height: string;\n    producer: string;\n    time: string;\n    transactions: Array<{\n      __typename: 'Transaction';\n      id: string;\n      rawPayload: string;\n      status?:\n        | {\n            __typename: 'FailureStatus';\n            time: string;\n            reason: string;\n            type: 'FailureStatus';\n            block: { __typename: 'Block'; id: string };\n          }\n        | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n        | {\n            __typename: 'SuccessStatus';\n            time: string;\n            type: 'SuccessStatus';\n            block: { __typename: 'Block'; id: string };\n            programState: { __typename: 'ProgramState'; returnType: GqlReturnType; data: string };\n          }\n        | null;\n    }>;\n  } | null;\n};\n\nexport type GqlGetBlocksQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetBlocksQuery = {\n  __typename: 'Query';\n  blocks: {\n    __typename: 'BlockConnection';\n    edges: Array<{\n      __typename: 'BlockEdge';\n      node: {\n        __typename: 'Block';\n        id: string;\n        height: string;\n        producer: string;\n        time: string;\n        transactions: Array<{ __typename: 'Transaction'; id: string }>;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetCoinQueryVariables = Exact<{\n  coinId: Scalars['UtxoId'];\n}>;\n\nexport type GqlGetCoinQuery = {\n  __typename: 'Query';\n  coin?: {\n    __typename: 'Coin';\n    utxoId: string;\n    owner: string;\n    amount: string;\n    assetId: string;\n    maturity: string;\n    status: GqlCoinStatus;\n    blockCreated: string;\n  } | null;\n};\n\nexport type GqlGetCoinsQueryVariables = Exact<{\n  filter: GqlCoinFilterInput;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetCoinsQuery = {\n  __typename: 'Query';\n  coins: {\n    __typename: 'CoinConnection';\n    edges: Array<{\n      __typename: 'CoinEdge';\n      node: {\n        __typename: 'Coin';\n        utxoId: string;\n        owner: string;\n        amount: string;\n        assetId: string;\n        maturity: string;\n        status: GqlCoinStatus;\n        blockCreated: string;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetCoinsToSpendQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  spendQuery: Array<GqlSpendQueryElementInput> | GqlSpendQueryElementInput;\n  maxInputs?: InputMaybe<Scalars['Int']>;\n  excludedIds?: InputMaybe<Array<Scalars['UtxoId']> | Scalars['UtxoId']>;\n}>;\n\nexport type GqlGetCoinsToSpendQuery = {\n  __typename: 'Query';\n  coinsToSpend: Array<{\n    __typename: 'Coin';\n    utxoId: string;\n    owner: string;\n    amount: string;\n    assetId: string;\n    maturity: string;\n    status: GqlCoinStatus;\n    blockCreated: string;\n  }>;\n};\n\nexport type GqlGetContractQueryVariables = Exact<{\n  contractId: Scalars['ContractId'];\n}>;\n\nexport type GqlGetContractQuery = {\n  __typename: 'Query';\n  contract?: { __typename: 'Contract'; bytecode: string; id: string } | null;\n};\n\nexport type GqlGetBalanceQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  assetId: Scalars['AssetId'];\n}>;\n\nexport type GqlGetBalanceQuery = {\n  __typename: 'Query';\n  balance: { __typename: 'Balance'; owner: string; amount: string; assetId: string };\n};\n\nexport type GqlGetBalancesQueryVariables = Exact<{\n  filter: GqlBalanceFilterInput;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetBalancesQuery = {\n  __typename: 'Query';\n  balances: {\n    __typename: 'BalanceConnection';\n    edges: Array<{\n      __typename: 'BalanceEdge';\n      node: { __typename: 'Balance'; owner: string; amount: string; assetId: string };\n    }>;\n  };\n};\n\nexport type GqlDryRunMutationVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n  utxoValidation?: InputMaybe<Scalars['Boolean']>;\n}>;\n\nexport type GqlDryRunMutation = {\n  __typename: 'Mutation';\n  dryRun: Array<{ __typename: 'Receipt'; data?: string | null; rawPayload: string }>;\n};\n\nexport type GqlSubmitMutationVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n}>;\n\nexport type GqlSubmitMutation = {\n  __typename: 'Mutation';\n  submit: { __typename: 'Transaction'; id: string };\n};\n\nexport type GqlStartSessionMutationVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlStartSessionMutation = { __typename: 'Mutation'; startSession: string };\n\nexport type GqlEndSessionMutationVariables = Exact<{\n  sessionId: Scalars['ID'];\n}>;\n\nexport type GqlEndSessionMutation = { __typename: 'Mutation'; endSession: boolean };\n\nexport type GqlExecuteMutationVariables = Exact<{\n  sessionId: Scalars['ID'];\n  op: Scalars['String'];\n}>;\n\nexport type GqlExecuteMutation = { __typename: 'Mutation'; execute: boolean };\n\nexport type GqlResetMutationVariables = Exact<{\n  sessionId: Scalars['ID'];\n}>;\n\nexport type GqlResetMutation = { __typename: 'Mutation'; reset: boolean };\n\nexport const TransactionFragmentFragmentDoc = gql`\n  fragment transactionFragment on Transaction {\n    id\n    rawPayload\n    status {\n      type: __typename\n      ... on SubmittedStatus {\n        time\n      }\n      ... on SuccessStatus {\n        block {\n          id\n        }\n        time\n        programState {\n          returnType\n          data\n        }\n      }\n      ... on FailureStatus {\n        block {\n          id\n        }\n        time\n        reason\n      }\n    }\n  }\n`;\nexport const ReceiptFragmentFragmentDoc = gql`\n  fragment receiptFragment on Receipt {\n    data\n    rawPayload\n  }\n`;\nexport const CoinFragmentFragmentDoc = gql`\n  fragment coinFragment on Coin {\n    utxoId\n    owner\n    amount\n    assetId\n    maturity\n    status\n    blockCreated\n  }\n`;\nexport const BalanceFragmentFragmentDoc = gql`\n  fragment balanceFragment on Balance {\n    owner\n    amount\n    assetId\n  }\n`;\nexport const BlockFragmentFragmentDoc = gql`\n  fragment blockFragment on Block {\n    id\n    height\n    producer\n    transactions {\n      id\n    }\n    time\n  }\n`;\nexport const ChainInfoFragmentFragmentDoc = gql`\n  fragment chainInfoFragment on ChainInfo {\n    name\n    baseChainHeight\n    peerCount\n    consensusParameters {\n      gasPriceFactor\n      maxGasPerTx\n      maxGasPerTx\n      maxScriptLength\n    }\n    latestBlock {\n      ...blockFragment\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n`;\nexport const GetVersionDocument = gql`\n  query getVersion {\n    nodeInfo {\n      nodeVersion\n    }\n  }\n`;\nexport const GetInfoDocument = gql`\n  query getInfo {\n    nodeInfo {\n      nodeVersion\n      minGasPrice\n    }\n  }\n`;\nexport const GetChainDocument = gql`\n  query getChain {\n    chain {\n      ...chainInfoFragment\n    }\n  }\n  ${ChainInfoFragmentFragmentDoc}\n`;\nexport const GetTransactionDocument = gql`\n  query getTransaction($transactionId: TransactionId!) {\n    transaction(id: $transactionId) {\n      ...transactionFragment\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetTransactionWithReceiptsDocument = gql`\n  query getTransactionWithReceipts($transactionId: TransactionId!) {\n    transaction(id: $transactionId) {\n      ...transactionFragment\n      receipts {\n        ...receiptFragment\n      }\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n  ${ReceiptFragmentFragmentDoc}\n`;\nexport const GetTransactionsDocument = gql`\n  query getTransactions($after: String, $before: String, $first: Int, $last: Int) {\n    transactions(after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...transactionFragment\n        }\n      }\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetTransactionsByOwnerDocument = gql`\n  query getTransactionsByOwner(\n    $owner: Address!\n    $after: String\n    $before: String\n    $first: Int\n    $last: Int\n  ) {\n    transactionsByOwner(owner: $owner, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...transactionFragment\n        }\n      }\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetBlockDocument = gql`\n  query getBlock($blockId: BlockId, $blockHeight: U64) {\n    block(id: $blockId, height: $blockHeight) {\n      ...blockFragment\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n`;\nexport const GetBlockWithTransactionsDocument = gql`\n  query getBlockWithTransactions($blockId: BlockId, $blockHeight: U64) {\n    block(id: $blockId, height: $blockHeight) {\n      ...blockFragment\n      transactions {\n        ...transactionFragment\n      }\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetBlocksDocument = gql`\n  query getBlocks($after: String, $before: String, $first: Int, $last: Int) {\n    blocks(after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...blockFragment\n        }\n      }\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n`;\nexport const GetCoinDocument = gql`\n  query getCoin($coinId: UtxoId!) {\n    coin(utxoId: $coinId) {\n      ...coinFragment\n    }\n  }\n  ${CoinFragmentFragmentDoc}\n`;\nexport const GetCoinsDocument = gql`\n  query getCoins(\n    $filter: CoinFilterInput!\n    $after: String\n    $before: String\n    $first: Int\n    $last: Int\n  ) {\n    coins(filter: $filter, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...coinFragment\n        }\n      }\n    }\n  }\n  ${CoinFragmentFragmentDoc}\n`;\nexport const GetCoinsToSpendDocument = gql`\n  query getCoinsToSpend(\n    $owner: Address!\n    $spendQuery: [SpendQueryElementInput!]!\n    $maxInputs: Int\n    $excludedIds: [UtxoId!]\n  ) {\n    coinsToSpend(\n      owner: $owner\n      spendQuery: $spendQuery\n      maxInputs: $maxInputs\n      excludedIds: $excludedIds\n    ) {\n      ...coinFragment\n    }\n  }\n  ${CoinFragmentFragmentDoc}\n`;\nexport const GetContractDocument = gql`\n  query getContract($contractId: ContractId!) {\n    contract(id: $contractId) {\n      bytecode\n      id\n    }\n  }\n`;\nexport const GetBalanceDocument = gql`\n  query getBalance($owner: Address!, $assetId: AssetId!) {\n    balance(owner: $owner, assetId: $assetId) {\n      ...balanceFragment\n    }\n  }\n  ${BalanceFragmentFragmentDoc}\n`;\nexport const GetBalancesDocument = gql`\n  query getBalances(\n    $filter: BalanceFilterInput!\n    $after: String\n    $before: String\n    $first: Int\n    $last: Int\n  ) {\n    balances(filter: $filter, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...balanceFragment\n        }\n      }\n    }\n  }\n  ${BalanceFragmentFragmentDoc}\n`;\nexport const DryRunDocument = gql`\n  mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {\n    dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {\n      ...receiptFragment\n    }\n  }\n  ${ReceiptFragmentFragmentDoc}\n`;\nexport const SubmitDocument = gql`\n  mutation submit($encodedTransaction: HexString!) {\n    submit(tx: $encodedTransaction) {\n      id\n    }\n  }\n`;\nexport const StartSessionDocument = gql`\n  mutation startSession {\n    startSession\n  }\n`;\nexport const EndSessionDocument = gql`\n  mutation endSession($sessionId: ID!) {\n    endSession(id: $sessionId)\n  }\n`;\nexport const ExecuteDocument = gql`\n  mutation execute($sessionId: ID!, $op: String!) {\n    execute(id: $sessionId, op: $op)\n  }\n`;\nexport const ResetDocument = gql`\n  mutation reset($sessionId: ID!) {\n    reset(id: $sessionId)\n  }\n`;\n\nexport type SdkFunctionWrapper = <T>(\n  action: (requestHeaders?: Record<string, string>) => Promise<T>,\n  operationName: string,\n  operationType?: string\n) => Promise<T>;\n\nconst defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();\n\nexport function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {\n  return {\n    getVersion(\n      variables?: GqlGetVersionQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetVersionQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetVersionQuery>(GetVersionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getVersion',\n        'query'\n      );\n    },\n    getInfo(\n      variables?: GqlGetInfoQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetInfoQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetInfoQuery>(GetInfoDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getInfo',\n        'query'\n      );\n    },\n    getChain(\n      variables?: GqlGetChainQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetChainQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetChainQuery>(GetChainDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getChain',\n        'query'\n      );\n    },\n    getTransaction(\n      variables: GqlGetTransactionQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionQuery>(GetTransactionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getTransaction',\n        'query'\n      );\n    },\n    getTransactionWithReceipts(\n      variables: GqlGetTransactionWithReceiptsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionWithReceiptsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionWithReceiptsQuery>(\n            GetTransactionWithReceiptsDocument,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders }\n          ),\n        'getTransactionWithReceipts',\n        'query'\n      );\n    },\n    getTransactions(\n      variables?: GqlGetTransactionsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionsQuery>(GetTransactionsDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getTransactions',\n        'query'\n      );\n    },\n    getTransactionsByOwner(\n      variables: GqlGetTransactionsByOwnerQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionsByOwnerQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionsByOwnerQuery>(\n            GetTransactionsByOwnerDocument,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders }\n          ),\n        'getTransactionsByOwner',\n        'query'\n      );\n    },\n    getBlock(\n      variables?: GqlGetBlockQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBlockQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBlockQuery>(GetBlockDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBlock',\n        'query'\n      );\n    },\n    getBlockWithTransactions(\n      variables?: GqlGetBlockWithTransactionsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBlockWithTransactionsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBlockWithTransactionsQuery>(\n            GetBlockWithTransactionsDocument,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders }\n          ),\n        'getBlockWithTransactions',\n        'query'\n      );\n    },\n    getBlocks(\n      variables?: GqlGetBlocksQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBlocksQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBlocksQuery>(GetBlocksDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBlocks',\n        'query'\n      );\n    },\n    getCoin(\n      variables: GqlGetCoinQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetCoinQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetCoinQuery>(GetCoinDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getCoin',\n        'query'\n      );\n    },\n    getCoins(\n      variables: GqlGetCoinsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetCoinsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetCoinsQuery>(GetCoinsDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getCoins',\n        'query'\n      );\n    },\n    getCoinsToSpend(\n      variables: GqlGetCoinsToSpendQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetCoinsToSpendQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetCoinsToSpendQuery>(GetCoinsToSpendDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getCoinsToSpend',\n        'query'\n      );\n    },\n    getContract(\n      variables: GqlGetContractQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetContractQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetContractQuery>(GetContractDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getContract',\n        'query'\n      );\n    },\n    getBalance(\n      variables: GqlGetBalanceQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBalanceQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBalanceQuery>(GetBalanceDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBalance',\n        'query'\n      );\n    },\n    getBalances(\n      variables: GqlGetBalancesQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBalancesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBalancesQuery>(GetBalancesDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBalances',\n        'query'\n      );\n    },\n    dryRun(\n      variables: GqlDryRunMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlDryRunMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlDryRunMutation>(DryRunDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'dryRun',\n        'mutation'\n      );\n    },\n    submit(\n      variables: GqlSubmitMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlSubmitMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlSubmitMutation>(SubmitDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'submit',\n        'mutation'\n      );\n    },\n    startSession(\n      variables?: GqlStartSessionMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlStartSessionMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlStartSessionMutation>(StartSessionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'startSession',\n        'mutation'\n      );\n    },\n    endSession(\n      variables: GqlEndSessionMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlEndSessionMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlEndSessionMutation>(EndSessionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'endSession',\n        'mutation'\n      );\n    },\n    execute(\n      variables: GqlExecuteMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlExecuteMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlExecuteMutation>(ExecuteDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'execute',\n        'mutation'\n      );\n    },\n    reset(\n      variables: GqlResetMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlResetMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlResetMutation>(ResetDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'reset',\n        'mutation'\n      );\n    },\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport type { Network } from '@ethersproject/networks';\nimport type { InputValue } from '@fuel-ts/abi-coder';\nimport { AbiCoder } from '@fuel-ts/abi-coder';\nimport { NativeAssetId } from '@fuel-ts/constants';\nimport type { AbstractAddress, AbstractPredicate } from '@fuel-ts/interfaces';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { max, bn, multiply } from '@fuel-ts/math';\nimport type { Transaction } from '@fuel-ts/transactions';\nimport {\n  GAS_PRICE_FACTOR,\n  MAX_GAS_PER_TX,\n  ReceiptType,\n  ReceiptCoder,\n  TransactionCoder,\n} from '@fuel-ts/transactions';\nimport { GraphQLClient } from 'graphql-request';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport type {\n  GqlChainInfoFragmentFragment,\n  GqlGetInfoQuery,\n  GqlReceiptFragmentFragment,\n} from './__generated__/operations';\nimport { getSdk as getOperationsSdk } from './__generated__/operations';\nimport type { Coin } from './coin';\nimport type { CoinQuantity, CoinQuantityLike } from './coin-quantity';\nimport { coinQuantityfy } from './coin-quantity';\nimport { ScriptTransactionRequest, transactionRequestify } from './transaction-request';\nimport type { TransactionRequestLike } from './transaction-request';\nimport type {\n  TransactionResult,\n  TransactionResultReceipt,\n} from './transaction-response/transaction-response';\nimport { TransactionResponse } from './transaction-response/transaction-response';\nimport { calculatePriceWithFactor, getGasUsedFromReceipts } from './util';\n\nexport type CallResult = {\n  receipts: TransactionResultReceipt[];\n};\n\n/**\n * A Fuel block\n */\nexport type Block = {\n  id: string;\n  height: BN;\n  time: string;\n  producer: string;\n  transactionIds: string[];\n};\n\n/**\n * Deployed Contract bytecode and contract id\n */\nexport type ContractResult = {\n  id: string;\n  bytecode: string;\n};\n\n/**\n * Chain information\n */\nexport type ChainInfo = {\n  name: string;\n  baseChainHeight: BN;\n  peerCount: number;\n  consensusParameters: {\n    gasPriceFactor: BN;\n    maxGasPerTx: BN;\n    maxScriptLength: BN;\n  };\n  latestBlock: {\n    id: string;\n    height: BN;\n    producer: string;\n    time: string;\n    transactions: Array<{ id: string }>;\n  };\n};\n\n/**\n * Node information\n */\nexport type NodeInfo = {\n  minGasPrice: BN;\n  nodeVersion: string;\n};\n\nexport type TransactionCost = {\n  minGasPrice: BN;\n  gasPrice: BN;\n  gasUsed: BN;\n  fee: BN;\n};\n\nconst processGqlReceipt = (gqlReceipt: GqlReceiptFragmentFragment): TransactionResultReceipt => {\n  const receipt = new ReceiptCoder().decode(arrayify(gqlReceipt.rawPayload), 0)[0];\n\n  switch (receipt.type) {\n    case ReceiptType.ReturnData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    case ReceiptType.LogData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    default:\n      return receipt;\n  }\n};\n\nconst processGqlChain = (chain: GqlChainInfoFragmentFragment): ChainInfo => ({\n  name: chain.name,\n  baseChainHeight: bn(chain.baseChainHeight),\n  peerCount: chain.peerCount,\n  consensusParameters: {\n    gasPriceFactor: bn(chain.consensusParameters.gasPriceFactor),\n    maxGasPerTx: bn(chain.consensusParameters.maxGasPerTx),\n    maxScriptLength: bn(chain.consensusParameters.maxScriptLength),\n  },\n  latestBlock: {\n    id: chain.latestBlock.id,\n    height: bn(chain.latestBlock.height),\n    producer: chain.latestBlock.producer,\n    time: chain.latestBlock.time,\n    transactions: chain.latestBlock.transactions.map((i) => ({\n      id: i.id,\n    })),\n  },\n});\n\nconst processNodeInfo = (nodeInfo: GqlGetInfoQuery['nodeInfo']) => ({\n  minGasPrice: bn(nodeInfo.minGasPrice),\n  nodeVersion: nodeInfo.nodeVersion,\n});\n\n/**\n * Cursor pagination arguments\n *\n * https://relay.dev/graphql/connections.htm#sec-Arguments\n */\nexport type CursorPaginationArgs = {\n  /** Forward pagination limit */\n  first?: number | null;\n  /** Forward pagination cursor */\n  after?: string | null;\n  /** Backward pagination limit  */\n  last?: number | null;\n  /** Backward pagination cursor */\n  before?: string | null;\n};\n\nexport type BuildPredicateOptions = {\n  fundTransaction?: boolean;\n} & Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'>;\n\n/**\n * Provider Call transaction params\n */\nexport type ProviderCallParams = {\n  utxoValidation?: boolean;\n};\n/**\n * A provider for connecting to a Fuel node\n */\nexport default class Provider {\n  operations: ReturnType<typeof getOperationsSdk>;\n\n  constructor(\n    /** GraphQL endpoint of the Fuel node */\n    public url: string\n  ) {\n    const gqlClient = new GraphQLClient(url);\n    this.operations = getOperationsSdk(gqlClient);\n  }\n\n  /**\n   * Returns the version of the connected Fuel node\n   */\n  async getVersion(): Promise<string> {\n    const {\n      nodeInfo: { nodeVersion },\n    } = await this.operations.getVersion();\n    return nodeVersion;\n  }\n\n  /**\n   * Returns the network configuration of the connected Fuel node\n   */\n  async getNetwork(): Promise<Network> {\n    return {\n      name: 'fuelv2',\n      chainId: 0xdeadbeef,\n    };\n  }\n\n  /**\n   * Returns the current block number\n   */\n  async getBlockNumber(): Promise<BN> {\n    const { chain } = await this.operations.getChain();\n    return bn(chain.latestBlock.height, 10);\n  }\n\n  /**\n   * Returns node information\n   */\n  async getNodeInfo(): Promise<NodeInfo> {\n    const { nodeInfo } = await this.operations.getInfo();\n    return processNodeInfo(nodeInfo);\n  }\n\n  /**\n   * Returns chain information\n   */\n  async getChain(): Promise<ChainInfo> {\n    const { chain } = await this.operations.getChain();\n    return processGqlChain(chain);\n  }\n\n  /**\n   * Submits a transaction to the chain to be executed\n   */\n  async sendTransaction(\n    transactionRequestLike: TransactionRequestLike\n  ): Promise<TransactionResponse> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { gasUsed, minGasPrice } = await this.getTransactionCost(transactionRequest, 0);\n\n    // Fail transaction before submit to avoid submit failure\n    // Resulting in lost of funds on a OutOfGas situation.\n    if (bn(gasUsed).gt(bn(transactionRequest.gasLimit))) {\n      throw new Error(\n        `gasLimit(${transactionRequest.gasLimit}) is lower than the required (${gasUsed})`\n      );\n    } else if (bn(minGasPrice).gt(bn(transactionRequest.gasPrice))) {\n      throw new Error(\n        `gasPrice(${transactionRequest.gasPrice}) is lower than the required ${minGasPrice}`\n      );\n    }\n\n    const {\n      submit: { id: transactionId },\n    } = await this.operations.submit({ encodedTransaction });\n\n    const response = new TransactionResponse(transactionId, transactionRequest, this);\n    return response;\n  }\n\n  /**\n   * Executes a transaction without actually submitting it to the chain\n   */\n  async call(\n    transactionRequestLike: TransactionRequestLike,\n    { utxoValidation }: ProviderCallParams = {}\n  ): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { dryRun: gqlReceipts } = await this.operations.dryRun({\n      encodedTransaction,\n      utxoValidation: utxoValidation || false,\n    });\n    const receipts = gqlReceipts.map(processGqlReceipt);\n    return {\n      receipts,\n    };\n  }\n\n  /**\n   * Returns a transaction cost to enable user\n   * to set gasLimit and also reserve balance amounts\n   * on the the transaction.\n   *\n   * The tolerance is add on top of the gasUsed calculated\n   * from the node, this create a safe margin costs like\n   * change states on transfer that don't occur on the dryRun\n   * transaction. The default value is 0.2 or 20%\n   */\n  async getTransactionCost(\n    transactionRequestLike: TransactionRequestLike,\n    tolerance: number = 0.2\n  ): Promise<TransactionCost> {\n    const transactionRequest = transactionRequestify(cloneDeep(transactionRequestLike));\n    const { minGasPrice } = await this.getNodeInfo();\n    const gasPrice = max(transactionRequest.gasPrice, minGasPrice);\n    const margin = 1 + tolerance;\n\n    // Set gasLimit to the maximum of the chain\n    // and gasPrice to 0 for measure\n    // Transaction without arrive to OutOfGas\n    transactionRequest.gasLimit = MAX_GAS_PER_TX;\n    transactionRequest.gasPrice = bn(0);\n\n    // Execute dryRun not validated transaction to query gasUsed\n    const { receipts } = await this.call(transactionRequest);\n    const gasUsed = multiply(getGasUsedFromReceipts(receipts), margin);\n    const gasFee = calculatePriceWithFactor(gasUsed, gasPrice, GAS_PRICE_FACTOR);\n\n    return {\n      minGasPrice,\n      gasPrice,\n      gasUsed,\n      fee: gasFee,\n    };\n  }\n\n  /**\n   * Returns coins for the given owner\n   */\n  async getCoins(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId?: BytesLike,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<Coin[]> {\n    const result = await this.operations.getCoins({\n      first: 10,\n      ...paginationArgs,\n      filter: { owner: owner.toB256(), assetId: assetId && hexlify(assetId) },\n    });\n\n    const coins = result.coins.edges!.map((edge) => edge!.node!);\n\n    return coins.map((coin) => ({\n      id: coin.utxoId,\n      assetId: coin.assetId,\n      amount: bn(coin.amount),\n      owner: coin.owner,\n      status: coin.status,\n      maturity: bn(coin.maturity).toNumber(),\n      blockCreated: bn(coin.blockCreated),\n    }));\n  }\n\n  /**\n   * Returns coins for the given owner satisfying the spend query\n   */\n  async getCoinsToSpend(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The quantitites to get */\n    quantities: CoinQuantityLike[],\n    /** Maximum number of coins to return */\n    maxInputs?: number,\n    /** IDs of coins to exclude */\n    excludedIds?: BytesLike[]\n  ): Promise<Coin[]> {\n    const result = await this.operations.getCoinsToSpend({\n      owner: owner.toB256(),\n      spendQuery: quantities.map(coinQuantityfy).map((quantity) => ({\n        assetId: hexlify(quantity.assetId),\n        amount: quantity.amount.toString(10),\n      })),\n      maxInputs,\n      excludedIds: excludedIds?.map((id) => hexlify(id)),\n    });\n\n    const coins = result.coinsToSpend;\n\n    return coins.map((coin) => ({\n      id: coin.utxoId,\n      status: coin.status,\n      assetId: coin.assetId,\n      amount: bn(coin.amount),\n      owner: coin.owner,\n      maturity: bn(coin.maturity).toNumber(),\n      blockCreated: bn(coin.blockCreated),\n    }));\n  }\n\n  /**\n   * Returns block matching the given ID or type\n   */\n  async getBlock(\n    /** ID or height of the block */\n    idOrHeight: string | number | 'latest'\n  ): Promise<Block | null> {\n    let variables;\n    if (typeof idOrHeight === 'number') {\n      variables = { blockHeight: bn(idOrHeight).toString(10) };\n    } else if (idOrHeight === 'latest') {\n      variables = { blockHeight: (await this.getBlockNumber()).toString(10) };\n    } else {\n      variables = { blockId: bn(idOrHeight).toString(10) };\n    }\n\n    const { block } = await this.operations.getBlock(variables);\n\n    if (!block) {\n      return null;\n    }\n\n    return {\n      id: block.id,\n      height: bn(block.height),\n      time: block.time,\n      producer: block.producer,\n      transactionIds: block.transactions.map((tx) => tx.id),\n    };\n  }\n\n  /**\n   * Returns block matching the given ID or type, including transaction data\n   */\n  async getBlockWithTransactions(\n    /** ID or height of the block */\n    idOrHeight: string | number | 'latest'\n  ): Promise<(Block & { transactions: Transaction[] }) | null> {\n    let variables;\n    if (typeof idOrHeight === 'number') {\n      variables = { blockHeight: bn(idOrHeight).toString(10) };\n    } else if (idOrHeight === 'latest') {\n      variables = { blockHeight: (await this.getBlockNumber()).toString() };\n    } else {\n      variables = { blockId: idOrHeight };\n    }\n\n    const { block } = await this.operations.getBlockWithTransactions(variables);\n\n    if (!block) {\n      return null;\n    }\n\n    return {\n      id: block.id,\n      height: bn(block.height, 10),\n      time: block.time,\n      producer: block.producer,\n      transactionIds: block.transactions.map((tx) => tx.id),\n      transactions: block.transactions.map(\n        (tx) => new TransactionCoder().decode(arrayify(tx.rawPayload), 0)?.[0]\n      ),\n    };\n  }\n\n  /**\n   * Get transaction with the given ID\n   */\n  async getTransaction(transactionId: string): Promise<Transaction | null> {\n    const { transaction } = await this.operations.getTransaction({ transactionId });\n    if (!transaction) {\n      return null;\n    }\n    return new TransactionCoder().decode(arrayify(transaction.rawPayload), 0)?.[0];\n  }\n\n  /**\n   * Get deployed contract with the given ID\n   *\n   * @returns contract bytecode and contract id\n   */\n  async getContract(contractId: string): Promise<ContractResult | null> {\n    const { contract } = await this.operations.getContract({ contractId });\n    if (!contract) {\n      return null;\n    }\n    return contract;\n  }\n\n  /**\n   * Returns the balance for the given owner for the given asset ID\n   */\n  async getBalance(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId: BytesLike\n  ): Promise<BN> {\n    const { balance } = await this.operations.getBalance({\n      owner: owner.toB256(),\n      assetId: hexlify(assetId),\n    });\n    return bn(balance.amount, 10);\n  }\n\n  /**\n   * Returns balances for the given owner\n   */\n  async getBalances(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<CoinQuantity[]> {\n    const result = await this.operations.getBalances({\n      first: 10,\n      ...paginationArgs,\n      filter: { owner: owner.toB256() },\n    });\n\n    const balances = result.balances.edges!.map((edge) => edge!.node!);\n\n    return balances.map((balance) => ({\n      assetId: balance.assetId,\n      amount: bn(balance.amount),\n    }));\n  }\n\n  async buildSpendPredicate(\n    predicate: AbstractPredicate,\n    amountToSpend: BigNumberish,\n    receiverAddress: AbstractAddress,\n    predicateData?: InputValue[],\n    assetId: BytesLike = NativeAssetId,\n    predicateOptions?: BuildPredicateOptions,\n    walletAddress?: AbstractAddress\n  ): Promise<ScriptTransactionRequest> {\n    const predicateCoins: Coin[] = await this.getCoinsToSpend(predicate.address, [\n      [amountToSpend, assetId],\n    ]);\n    const options = {\n      fundTransaction: true,\n      ...predicateOptions,\n    };\n    const request = new ScriptTransactionRequest({\n      gasLimit: MAX_GAS_PER_TX,\n      ...options,\n    });\n\n    let encoded: undefined | Uint8Array;\n    if (predicateData && predicate.types) {\n      const abiCoder = new AbiCoder();\n      encoded = abiCoder.encode(predicate.types, predicateData);\n    }\n\n    const totalInPredicate: BN = predicateCoins.reduce((prev: BN, coin: Coin) => {\n      request.addCoin({\n        ...coin,\n        predicate: predicate.bytes,\n        predicateData: encoded,\n      } as Coin);\n      request.outputs = [];\n\n      return prev.add(coin.amount);\n    }, bn(0));\n\n    // output sent to receiver\n    request.addCoinOutput(receiverAddress, totalInPredicate, assetId);\n\n    const requiredCoinQuantities: CoinQuantityLike[] = [];\n    if (options.fundTransaction) {\n      requiredCoinQuantities.push(request.calculateFee());\n    }\n\n    if (requiredCoinQuantities.length && walletAddress) {\n      const coins = await this.getCoinsToSpend(walletAddress, requiredCoinQuantities);\n      request.addCoins(coins);\n    }\n\n    return request;\n  }\n\n  async submitSpendPredicate(\n    predicate: AbstractPredicate,\n    amountToSpend: BigNumberish,\n    receiverAddress: AbstractAddress,\n    predicateData?: InputValue[],\n    assetId: BytesLike = NativeAssetId,\n    options?: BuildPredicateOptions,\n    walletAddress?: AbstractAddress\n  ): Promise<TransactionResult<'success'>> {\n    const request = await this.buildSpendPredicate(\n      predicate,\n      amountToSpend,\n      receiverAddress,\n      predicateData,\n      assetId,\n      options,\n      walletAddress\n    );\n\n    try {\n      const response = await this.sendTransaction(request);\n      return await response.waitForResult();\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      const errors: { message: string }[] = error?.response?.errors || [];\n      if (\n        errors.some(({ message }) =>\n          message.includes('unexpected block execution error TransactionValidity(InvalidPredicate')\n        )\n      ) {\n        throw new Error('Invalid Predicate');\n      }\n\n      throw error;\n    }\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { ZeroBytes32 } from '@fuel-ts/constants';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport { bn, toNumber } from '@fuel-ts/math';\nimport type { Input } from '@fuel-ts/transactions';\nimport { InputType } from '@fuel-ts/transactions';\n\nexport type CoinTransactionRequestInput = {\n  type: InputType.Coin;\n\n  /** UTXO ID */\n  id: BytesLike;\n\n  /** Owning address or script hash */\n  owner: BytesLike;\n\n  /** Amount of coins */\n  amount: BigNumberish;\n\n  /** Asset ID of the coins */\n  assetId: BytesLike;\n\n  /** Points to the TX whose output is being spent. (TxPointer) */\n  txPointer: BytesLike;\n\n  /** Index of witness that authorizes spending the coin */\n  witnessIndex: number;\n\n  /** UTXO being spent must have been created at least this many blocks ago */\n  maturity?: number;\n\n  /** Predicate bytecode */\n  predicate?: BytesLike;\n\n  /** Predicate input data (parameters) */\n  predicateData?: BytesLike;\n};\nexport type ContractTransactionRequestInput = {\n  type: InputType.Contract;\n\n  /** Points to the TX whose output is being spent. (TxPointer) */\n  txPointer: BytesLike;\n\n  /** Contract ID */\n  contractId: BytesLike;\n};\nexport type TransactionRequestInput = CoinTransactionRequestInput | ContractTransactionRequestInput;\n\nexport const inputify = (value: TransactionRequestInput): Input => {\n  switch (value.type) {\n    case InputType.Coin: {\n      const predicate = arrayify(value.predicate ?? '0x');\n      const predicateData = arrayify(value.predicateData ?? '0x');\n      return {\n        type: InputType.Coin,\n        utxoID: {\n          transactionId: hexlify(arrayify(value.id).slice(0, 32)),\n          outputIndex: arrayify(value.id)[32],\n        },\n        owner: hexlify(value.owner),\n        amount: bn(value.amount),\n        assetId: hexlify(value.assetId),\n        txPointer: {\n          blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),\n          txIndex: toNumber(arrayify(value.txPointer).slice(8, 16)),\n        },\n        witnessIndex: value.witnessIndex,\n        maturity: value.maturity ?? 0,\n        predicateLength: predicate.length,\n        predicateDataLength: predicateData.length,\n        predicate: hexlify(predicate),\n        predicateData: hexlify(predicateData),\n      };\n    }\n    case InputType.Contract: {\n      return {\n        type: InputType.Contract,\n        utxoID: {\n          transactionId: ZeroBytes32,\n          outputIndex: 0,\n        },\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n        txPointer: {\n          blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),\n          txIndex: toNumber(arrayify(value.txPointer).slice(8, 16)),\n        },\n        contractID: hexlify(value.contractId),\n      };\n    }\n    default: {\n      throw new Error('Invalid Input type');\n    }\n  }\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify } from '@ethersproject/bytes';\nimport { ZeroBytes32 } from '@fuel-ts/constants';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { Output } from '@fuel-ts/transactions';\nimport { OutputType } from '@fuel-ts/transactions';\n\nexport type CoinTransactionRequestOutput = {\n  type: OutputType.Coin;\n  /** Receiving address or script hash */\n  to: BytesLike;\n  /** Amount of coins to send */\n  amount: BigNumberish;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type ContractTransactionRequestOutput = {\n  type: OutputType.Contract;\n  /** Index of input contract */\n  inputIndex: number;\n};\nexport type WithdrawalTransactionRequestOutput = {\n  type: OutputType.Withdrawal;\n  /** Receiving address */\n  to: BytesLike;\n  /** Amount of coins to withdraw */\n  amount: BigNumberish;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type ChangeTransactionRequestOutput = {\n  type: OutputType.Change;\n  /** Receiving address or script hash */\n  to: BytesLike;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type VariableTransactionRequestOutput = {\n  type: OutputType.Variable;\n};\nexport type ContractCreatedTransactionRequestOutput = {\n  type: OutputType.ContractCreated;\n  /** Contract ID */\n  contractId: BytesLike;\n  /** State Root */\n  stateRoot: BytesLike;\n};\nexport type TransactionRequestOutput =\n  | CoinTransactionRequestOutput\n  | ContractTransactionRequestOutput\n  | WithdrawalTransactionRequestOutput\n  | ChangeTransactionRequestOutput\n  | VariableTransactionRequestOutput\n  | ContractCreatedTransactionRequestOutput;\n\nexport const outputify = (value: TransactionRequestOutput): Output => {\n  switch (value.type) {\n    case OutputType.Coin: {\n      return {\n        type: OutputType.Coin,\n        to: hexlify(value.to),\n        amount: bn(value.amount),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Contract: {\n      return {\n        type: OutputType.Contract,\n        inputIndex: value.inputIndex,\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n      };\n    }\n    case OutputType.Withdrawal: {\n      return {\n        type: OutputType.Withdrawal,\n        to: hexlify(value.to),\n        amount: bn(value.amount),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Change: {\n      return {\n        type: OutputType.Change,\n        to: hexlify(value.to),\n        amount: bn(0),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Variable: {\n      return {\n        type: OutputType.Variable,\n        to: ZeroBytes32,\n        amount: bn(0),\n        assetId: ZeroBytes32,\n      };\n    }\n    case OutputType.ContractCreated: {\n      return {\n        type: OutputType.ContractCreated,\n        contractId: hexlify(value.contractId),\n        stateRoot: hexlify(value.stateRoot),\n      };\n    }\n    default: {\n      throw new Error('Invalid Output type');\n    }\n  }\n};\n","/* eslint-disable max-classes-per-file */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { addressify, Address } from '@fuel-ts/address';\nimport { NativeAssetId, ZeroBytes32 } from '@fuel-ts/constants';\nimport type {\n  AddressLike,\n  AbstractAddress,\n  ContractIdLike,\n  AbstractScript,\n} from '@fuel-ts/interfaces';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { bn, multiply } from '@fuel-ts/math';\nimport type { Transaction } from '@fuel-ts/transactions';\nimport {\n  TransactionType,\n  TransactionCoder,\n  InputType,\n  OutputType,\n  GAS_PRICE_FACTOR,\n} from '@fuel-ts/transactions';\n\nimport type { Coin } from '../coin';\nimport type { CoinQuantity, CoinQuantityLike } from '../coin-quantity';\nimport { coinQuantityfy } from '../coin-quantity';\nimport { calculatePriceWithFactor } from '../util';\n\nimport type {\n  CoinTransactionRequestOutput,\n  ContractCreatedTransactionRequestOutput,\n  ContractTransactionRequestOutput,\n  VariableTransactionRequestOutput,\n} from '.';\nimport type {\n  TransactionRequestInput,\n  CoinTransactionRequestInput,\n  ContractTransactionRequestInput,\n} from './input';\nimport { inputify } from './input';\nimport type { TransactionRequestOutput, ChangeTransactionRequestOutput } from './output';\nimport { outputify } from './output';\nimport type { TransactionRequestStorageSlot } from './storage-slot';\nimport { storageSlotify } from './storage-slot';\nimport type { TransactionRequestWitness } from './witness';\nimport { witnessify } from './witness';\n\nexport { TransactionType };\n\n// We can't import this from `@fuel-ts/script` because it causes\n// cyclic dependency errors so we duplicate it here.\nexport const returnZeroScript: AbstractScript<void> = {\n  /*\n    Opcode::RET(REG_ZERO)\n    Opcode::NOOP\n  */\n  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281\n  bytes: arrayify('0x24000000'),\n  encodeScriptData: () => new Uint8Array(0),\n};\n\ninterface BaseTransactionRequestLike {\n  /** Gas price for transaction */\n  gasPrice?: BigNumberish;\n  /** Gas limit for transaction */\n  gasLimit?: BigNumberish;\n  /** Block until which tx cannot be included */\n  maturity?: number;\n  /** List of inputs */\n  inputs?: TransactionRequestInput[];\n  /** List of outputs */\n  outputs?: TransactionRequestOutput[];\n  /** List of witnesses */\n  witnesses?: TransactionRequestWitness[];\n}\n\nexport class ChangeOutputCollisionError extends Error {\n  name = 'ChangeOutputCollisionError';\n  message = 'A ChangeOutput with the same \"assetId\" already exists for a different \"to\" address';\n}\n\nexport class NoWitnessAtIndexError extends Error {\n  name = 'NoWitnessAtIndexError';\n  constructor(public readonly index: number) {\n    super();\n    this.message = `Witness at index \"${index}\" was not found`;\n  }\n}\n\nexport class NoWitnessByOwnerError extends Error {\n  name = 'NoWitnessByOwnerError';\n  constructor(public readonly owner: AbstractAddress) {\n    super();\n    this.message = `A witness for the given owner \"${owner}\" was not found`;\n  }\n}\n\nabstract class BaseTransactionRequest implements BaseTransactionRequestLike {\n  /** Type of the transaction */\n  abstract type: TransactionType;\n  /** Gas price for transaction */\n  gasPrice: BN;\n  /** Gas limit for transaction */\n  gasLimit: BN;\n  /** Block until which tx cannot be included */\n  maturity: number;\n  /** List of inputs */\n  inputs: TransactionRequestInput[] = [];\n  /** List of outputs */\n  outputs: TransactionRequestOutput[] = [];\n  /** List of witnesses */\n  witnesses: TransactionRequestWitness[] = [];\n\n  constructor({\n    gasPrice,\n    gasLimit,\n    maturity,\n    inputs,\n    outputs,\n    witnesses,\n  }: BaseTransactionRequestLike = {}) {\n    this.gasPrice = bn(gasPrice ?? 0);\n    this.gasLimit = bn(gasLimit ?? 0);\n    this.maturity = maturity ?? 0;\n    this.inputs = [...(inputs ?? [])];\n    this.outputs = [...(outputs ?? [])];\n    this.witnesses = [...(witnesses ?? [])];\n  }\n\n  protected getBaseTransaction(): Pick<\n    Transaction,\n    keyof BaseTransactionRequestLike | 'inputsCount' | 'outputsCount' | 'witnessesCount'\n  > {\n    const inputs = this.inputs?.map(inputify) ?? [];\n    const outputs = this.outputs?.map(outputify) ?? [];\n    const witnesses = this.witnesses?.map(witnessify) ?? [];\n    return {\n      gasPrice: this.gasPrice,\n      gasLimit: this.gasLimit,\n      maturity: this.maturity,\n      inputs,\n      outputs,\n      witnesses,\n      inputsCount: inputs.length,\n      outputsCount: outputs.length,\n      witnessesCount: witnesses.length,\n    };\n  }\n\n  abstract toTransaction(): Transaction;\n\n  toTransactionBytes(): Uint8Array {\n    return new TransactionCoder().encode(this.toTransaction());\n  }\n\n  /**\n   * Pushes an input to the list without any side effects and returns the index\n   */\n  protected pushInput(input: TransactionRequestInput): number {\n    this.inputs.push(input);\n    return this.inputs.length - 1;\n  }\n\n  /**\n   * Pushes an output to the list without any side effects and returns the index\n   */\n  protected pushOutput(output: TransactionRequestOutput): number {\n    this.outputs.push(output);\n    return this.outputs.length - 1;\n  }\n\n  /**\n   * Creates an empty witness without any side effects and returns the index\n   */\n  protected createWitness() {\n    this.witnesses.push('0x');\n    return this.witnesses.length - 1;\n  }\n\n  /**\n   * Updates an existing witness without any side effects\n   */\n  updateWitness(index: number, witness: TransactionRequestWitness) {\n    if (!this.witnesses[index]) {\n      throw new NoWitnessAtIndexError(index);\n    }\n    this.witnesses[index] = witness;\n  }\n\n  getCoinInputs(): CoinTransactionRequestInput[] {\n    return this.inputs.filter(\n      (input): input is CoinTransactionRequestInput => input.type === InputType.Coin\n    );\n  }\n\n  getCoinOutputs(): CoinTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is CoinTransactionRequestOutput => output.type === OutputType.Coin\n    );\n  }\n\n  getChangeOutputs(): ChangeTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ChangeTransactionRequestOutput => output.type === OutputType.Change\n    );\n  }\n\n  /**\n   * Returns the witnessIndex of the found CoinInput\n   */\n  getCoinInputWitnessIndexByOwner(owner: AddressLike): number | null {\n    const ownerAddress = addressify(owner);\n    return (\n      this.inputs.find(\n        (input): input is CoinTransactionRequestInput =>\n          input.type === InputType.Coin && input.owner === ownerAddress.toB256()\n      )?.witnessIndex ?? null\n    );\n  }\n\n  /**\n   * Updates the witness for the given CoinInput owner\n   */\n  updateWitnessByCoinInputOwner(owner: AddressLike, witness: BytesLike) {\n    const witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);\n\n    if (!witnessIndex) {\n      throw new NoWitnessByOwnerError(addressify(owner));\n    }\n\n    this.updateWitness(witnessIndex, witness);\n  }\n\n  /**\n   * Converts the given Coin to a CoinInput with the appropriate witnessIndex and pushes it\n   */\n  addCoin(coin: Coin) {\n    let witnessIndex = this.getCoinInputWitnessIndexByOwner(Address.fromB256(coin.owner));\n\n    // Insert a dummy witness if no witness exists\n    if (typeof witnessIndex !== 'number') {\n      witnessIndex = this.createWitness();\n    }\n\n    // Insert the CoinInput\n    this.pushInput({\n      type: InputType.Coin,\n      ...coin,\n      witnessIndex,\n      txPointer: '0x00000000000000000000000000000000',\n    });\n\n    // Find the ChangeOutput for the AssetId of the Coin\n    const changeOutput = this.getChangeOutputs().find(\n      (output) => hexlify(output.assetId) === coin.assetId\n    );\n\n    // Throw if the existing ChangeOutput is not for the same owner\n    if (changeOutput && hexlify(changeOutput.to) !== coin.owner) {\n      throw new ChangeOutputCollisionError();\n    }\n\n    // Insert a ChangeOutput if it does not exist\n    if (!changeOutput) {\n      this.pushOutput({\n        type: OutputType.Change,\n        to: coin.owner,\n        assetId: coin.assetId,\n      });\n    }\n  }\n\n  addCoins(coins: ReadonlyArray<Coin>) {\n    coins.forEach((coin) => this.addCoin(coin));\n  }\n\n  addCoinOutput(\n    /** Address of the destination */\n    to: AddressLike,\n    /** Amount of coins */\n    amount: BigNumberish,\n    /** Asset ID of coins */\n    assetId: BytesLike = NativeAssetId\n  ) {\n    this.pushOutput({\n      type: OutputType.Coin,\n      to: addressify(to).toB256(),\n      amount,\n      assetId,\n    });\n  }\n\n  addCoinOutputs(\n    /** Address of the destination */\n    to: AddressLike,\n    /** Quantities of coins */\n    quantities: CoinQuantityLike[]\n  ) {\n    quantities.map(coinQuantityfy).forEach((quantity) => {\n      this.pushOutput({\n        type: OutputType.Coin,\n        to: addressify(to).toB256(),\n        amount: quantity.amount,\n        assetId: quantity.assetId,\n      });\n    });\n  }\n\n  byteSize() {\n    return this.toTransactionBytes().length;\n  }\n\n  chargeableByteSize() {\n    const witnessSize = this.witnesses.reduce((total, w) => total + arrayify(w).length, 0);\n    return bn(this.toTransactionBytes().length - witnessSize);\n  }\n\n  /**\n   * Return the minimum amount in native coins required to create\n   * a transaction.\n   *\n   * Note: this is required even gasPrice = 0\n   */\n  calculateFee(): CoinQuantity {\n    const gasFee = calculatePriceWithFactor(this.gasLimit, this.gasPrice, GAS_PRICE_FACTOR);\n\n    return {\n      assetId: NativeAssetId,\n      amount: gasFee.isZero() ? bn(1) : gasFee,\n    };\n  }\n}\n\nexport interface ScriptTransactionRequestLike extends BaseTransactionRequestLike {\n  /** Script to execute */\n  script?: BytesLike;\n  /** Script input data (parameters) */\n  scriptData?: BytesLike;\n}\n\nexport class ScriptTransactionRequest extends BaseTransactionRequest {\n  static from(obj: ScriptTransactionRequestLike) {\n    if (obj instanceof this) {\n      return obj;\n    }\n    return new this(obj);\n  }\n\n  /** Type of the transaction */\n  type = TransactionType.Script as const;\n  /** Script to execute */\n  script: Uint8Array;\n  /** Script input data (parameters) */\n  scriptData: Uint8Array;\n  /** determined bytes offset for start of script data */\n  bytesOffset: number | undefined;\n\n  constructor({ script, scriptData, ...rest }: ScriptTransactionRequestLike = {}) {\n    super(rest);\n    this.script = arrayify(script ?? returnZeroScript.bytes);\n    this.scriptData = arrayify(scriptData ?? returnZeroScript.encodeScriptData());\n  }\n\n  toTransaction(): Transaction {\n    const script = arrayify(this.script ?? '0x');\n    const scriptData = arrayify(this.scriptData ?? '0x');\n    return {\n      type: TransactionType.Script,\n      ...super.getBaseTransaction(),\n      scriptLength: script.length,\n      scriptDataLength: scriptData.length,\n      receiptsRoot: ZeroBytes32,\n      script: hexlify(script),\n      scriptData: hexlify(scriptData),\n    };\n  }\n\n  getContractInputs(): ContractTransactionRequestInput[] {\n    return this.inputs.filter(\n      (input): input is ContractTransactionRequestInput => input.type === InputType.Contract\n    );\n  }\n\n  getContractOutputs(): ContractTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ContractTransactionRequestOutput => output.type === OutputType.Contract\n    );\n  }\n\n  getVariableOutputs(): VariableTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is VariableTransactionRequestOutput => output.type === OutputType.Variable\n    );\n  }\n\n  setScript<T>(script: AbstractScript<T>, data: T) {\n    this.script = script.bytes;\n    this.scriptData = script.encodeScriptData(data);\n\n    if (this.bytesOffset === undefined) {\n      this.bytesOffset = this.scriptData.byteLength;\n    }\n  }\n\n  addVariableOutputs(numberOfVariables: number = 1) {\n    let outputsNumber = numberOfVariables;\n\n    while (outputsNumber) {\n      this.pushOutput({\n        type: OutputType.Variable,\n      });\n      outputsNumber -= 1;\n    }\n\n    return this.outputs.length - 1;\n  }\n\n  addContract(contract: ContractIdLike) {\n    const contractAddress = addressify(contract);\n\n    // Add only one input contract per contractId\n    if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {\n      return;\n    }\n\n    const inputIndex = super.pushInput({\n      type: InputType.Contract,\n      contractId: contractAddress.toB256(),\n      txPointer: '0x00000000000000000000000000000000',\n    });\n\n    this.pushOutput({\n      type: OutputType.Contract,\n      inputIndex,\n    });\n  }\n}\n\nexport interface CreateTransactionRequestLike extends BaseTransactionRequestLike {\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex?: number;\n  /** Salt */\n  salt?: BytesLike;\n  /** List of storage slots to initialize */\n  storageSlots?: TransactionRequestStorageSlot[];\n}\n\nexport class CreateTransactionRequest extends BaseTransactionRequest {\n  static from(obj: CreateTransactionRequestLike) {\n    if (obj instanceof this) {\n      return obj;\n    }\n    return new this(obj);\n  }\n\n  /** Type of the transaction */\n  type = TransactionType.Create as const;\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex: number;\n  /** Salt */\n  salt: string;\n  /** List of storage slots to initialize */\n  storageSlots: TransactionRequestStorageSlot[];\n\n  constructor({\n    bytecodeWitnessIndex,\n    salt,\n    storageSlots,\n    ...rest\n  }: CreateTransactionRequestLike = {}) {\n    super(rest);\n    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;\n    this.salt = hexlify(salt ?? ZeroBytes32);\n    this.storageSlots = [...(storageSlots ?? [])];\n  }\n\n  toTransaction(): Transaction {\n    const baseTransaction = this.getBaseTransaction();\n    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;\n    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];\n    return {\n      type: TransactionType.Create,\n      ...baseTransaction,\n      bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,\n      bytecodeWitnessIndex,\n      storageSlotsCount: storageSlots.length,\n      salt: this.salt ? hexlify(this.salt) : ZeroBytes32,\n      storageSlots,\n    };\n  }\n\n  getContractCreatedOutputs(): ContractCreatedTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ContractCreatedTransactionRequestOutput =>\n        output.type === OutputType.ContractCreated\n    );\n  }\n\n  addContractCreatedOutput(\n    /** Contract ID */\n    contractId: BytesLike,\n    /** State Root */\n    stateRoot: BytesLike\n  ) {\n    this.pushOutput({\n      type: OutputType.ContractCreated,\n      contractId,\n      stateRoot,\n    });\n  }\n}\n\nexport type TransactionRequest = ScriptTransactionRequest | CreateTransactionRequest;\nexport type TransactionRequestLike =\n  | ({ type: TransactionType.Script } & ScriptTransactionRequestLike)\n  | ({ type: TransactionType.Create } & CreateTransactionRequestLike);\n\nexport const transactionRequestify = (obj: TransactionRequestLike): TransactionRequest => {\n  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {\n    return obj;\n  }\n  switch (obj.type) {\n    case TransactionType.Script: {\n      return ScriptTransactionRequest.from(obj);\n    }\n    case TransactionType.Create: {\n      return CreateTransactionRequest.from(obj);\n    }\n    default: {\n      throw new Error(\n        `Unknown transaction type: ${\n          // @ts-expect-error Unreachable code\n          obj.type\n        }`\n      );\n    }\n  }\n};\n","import { sha256 } from '@ethersproject/sha2';\nimport { ZeroBytes32 } from '@fuel-ts/constants';\nimport type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { Transaction } from '@fuel-ts/transactions';\nimport {\n  ReceiptType,\n  InputType,\n  OutputType,\n  TransactionType,\n  TransactionCoder,\n} from '@fuel-ts/transactions';\n\nimport type { TransactionResultReceipt } from './transaction-response';\n\nexport const getSignableTransaction = (transaction: Transaction): Transaction => {\n  const signableTransaction = { ...transaction } as Transaction;\n  switch (signableTransaction.type) {\n    case TransactionType.Script: {\n      signableTransaction.receiptsRoot = ZeroBytes32;\n      break;\n    }\n    case TransactionType.Create: {\n      break;\n    }\n    default: {\n      throw new Error('Not implemented');\n    }\n  }\n\n  signableTransaction.inputs = signableTransaction.inputs.map((input) => {\n    if (input.type === InputType.Contract) {\n      return {\n        ...input,\n        utxoID: {\n          transactionId: ZeroBytes32,\n          outputIndex: 0,\n        },\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n      };\n    }\n    return input;\n  });\n\n  signableTransaction.outputs = signableTransaction.outputs.map((output) => {\n    switch (output.type) {\n      case OutputType.Contract: {\n        return {\n          ...output,\n          balanceRoot: ZeroBytes32,\n          stateRoot: ZeroBytes32,\n        };\n      }\n      case OutputType.Change: {\n        return {\n          ...output,\n          amount: bn(0),\n        };\n      }\n      case OutputType.Variable: {\n        return {\n          ...output,\n          to: ZeroBytes32,\n          amount: bn(0),\n          assetId: ZeroBytes32,\n        };\n      }\n      default: {\n        return output;\n      }\n    }\n  });\n\n  return signableTransaction;\n};\n\nexport const getTransactionId = (transaction: Transaction): string => {\n  const signableTransaction = getSignableTransaction(transaction);\n\n  const encodedTransaction = new TransactionCoder().encode(signableTransaction);\n\n  return sha256(encodedTransaction);\n};\n\nexport const calculatePriceWithFactor = (gasUsed: BN, gasPrice: BN, priceFactor: BN): BN =>\n  bn(Math.ceil(gasUsed.toNumber() / priceFactor.toNumber()) * gasPrice.toNumber());\n\nexport const getGasUsedFromReceipts = (receipts: Array<TransactionResultReceipt>): BN => {\n  const scriptResult = receipts.find((receipt) => receipt.type === ReceiptType.ScriptResult);\n\n  if (scriptResult && scriptResult.type === ReceiptType.ScriptResult) {\n    return scriptResult.gasUsed;\n  }\n\n  return bn(0);\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify, arrayify } from '@ethersproject/bytes';\nimport type { StorageSlot } from '@fuel-ts/transactions';\n\nexport type TransactionRequestStorageSlot =\n  | {\n      /** Key */\n      key: BytesLike;\n      /** Value */\n      value: BytesLike;\n    }\n  | [key: BytesLike, value: BytesLike];\n\n// Make sure all values have 32 bytes\nconst getStorageValue = (value: BytesLike): Uint8Array => {\n  const v = new Uint8Array(32);\n  v.set(arrayify(value));\n  return v;\n};\n\nexport const storageSlotify = (storageSlot: TransactionRequestStorageSlot): StorageSlot => {\n  let key;\n  let value;\n\n  if (Array.isArray(storageSlot)) {\n    key = storageSlot[0];\n    value = storageSlot[1];\n  } else {\n    key = storageSlot.key;\n    value = storageSlot.value;\n  }\n\n  return {\n    key: hexlify(key),\n    value: hexlify(getStorageValue(value)),\n  };\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport type { Witness } from '@fuel-ts/transactions';\n\nexport type TransactionRequestWitness = BytesLike;\n\nexport const witnessify = (value: TransactionRequestWitness): Witness => {\n  const data = arrayify(value);\n\n  return {\n    data: hexlify(data),\n    dataLength: data.length,\n  };\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { arrayify } from '@ethersproject/bytes';\nimport type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type {\n  ReceiptCall,\n  ReceiptLog,\n  ReceiptLogData,\n  ReceiptPanic,\n  ReceiptReturn,\n  ReceiptReturnData,\n  ReceiptRevert,\n  ReceiptTransfer,\n  ReceiptTransferOut,\n  ReceiptScriptResult,\n} from '@fuel-ts/transactions';\nimport { ReceiptType, ReceiptCoder } from '@fuel-ts/transactions';\n\nimport type {\n  GqlGetTransactionWithReceiptsQuery,\n  GqlReceiptFragmentFragment,\n} from '../__generated__/operations';\nimport type Provider from '../provider';\nimport type { TransactionRequest } from '../transaction-request';\nimport { getGasUsedFromReceipts } from '../util';\n\nexport type TransactionResultCallReceipt = ReceiptCall;\nexport type TransactionResultReturnReceipt = ReceiptReturn;\nexport type TransactionResultReturnDataReceipt = ReceiptReturnData & { data: string };\nexport type TransactionResultPanicReceipt = ReceiptPanic;\nexport type TransactionResultRevertReceipt = ReceiptRevert;\nexport type TransactionResultLogReceipt = ReceiptLog;\nexport type TransactionResultLogDataReceipt = ReceiptLogData & { data: string };\nexport type TransactionResultTransferReceipt = ReceiptTransfer;\nexport type TransactionResultTransferOutReceipt = ReceiptTransferOut;\nexport type TransactionResultScriptResultReceipt = ReceiptScriptResult;\n\nexport type TransactionResultReceipt =\n  | TransactionResultCallReceipt\n  | TransactionResultReturnReceipt\n  | TransactionResultReturnDataReceipt\n  | TransactionResultPanicReceipt\n  | TransactionResultRevertReceipt\n  | TransactionResultLogReceipt\n  | TransactionResultLogDataReceipt\n  | TransactionResultTransferReceipt\n  | TransactionResultTransferOutReceipt\n  | TransactionResultScriptResultReceipt;\n\nexport type TransactionResult<TStatus extends 'success' | 'failure'> = {\n  status: TStatus extends 'success'\n    ? { type: 'success'; programState: any }\n    : { type: 'failure'; reason: any };\n  /** Receipts produced during the execution of the transaction */\n  receipts: TransactionResultReceipt[];\n  transactionId: string;\n  blockId: any;\n  time: any;\n};\n\nconst processGqlReceipt = (gqlReceipt: GqlReceiptFragmentFragment): TransactionResultReceipt => {\n  const receipt = new ReceiptCoder().decode(arrayify(gqlReceipt.rawPayload), 0)[0];\n\n  switch (receipt.type) {\n    case ReceiptType.ReturnData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    case ReceiptType.LogData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    default:\n      return receipt;\n  }\n};\n\nexport class TransactionResponse {\n  /** Transaction ID */\n  id: string;\n  /** Transaction request */\n  request: TransactionRequest;\n  provider: Provider;\n  /** Gas used on the transaction */\n  gasUsed: BN = bn(0);\n\n  constructor(id: string, request: TransactionRequest, provider: Provider) {\n    this.id = id;\n    this.request = request;\n    this.provider = provider;\n  }\n\n  async #fetch(): Promise<NonNullable<GqlGetTransactionWithReceiptsQuery['transaction']>> {\n    const { transaction } = await this.provider.operations.getTransactionWithReceipts({\n      transactionId: this.id,\n    });\n    if (!transaction) {\n      throw new Error('No Transaction was received from the client.');\n    }\n    return transaction;\n  }\n\n  /** Waits for transaction to succeed or fail and returns the result */\n  async waitForResult(): Promise<TransactionResult<any>> {\n    const transaction = await this.#fetch();\n\n    switch (transaction.status?.type) {\n      case 'SubmittedStatus': {\n        // TODO: Implement polling or GQL subscription\n        throw new Error('Not yet implemented');\n      }\n      case 'FailureStatus': {\n        const receipts = transaction.receipts!.map(processGqlReceipt);\n        this.gasUsed = getGasUsedFromReceipts(receipts);\n        return {\n          status: { type: 'failure', reason: transaction.status.reason },\n          receipts,\n          transactionId: this.id,\n          blockId: transaction.status.block.id,\n          time: transaction.status.time,\n        };\n      }\n      case 'SuccessStatus': {\n        const receipts = transaction.receipts!.map(processGqlReceipt);\n        this.gasUsed = getGasUsedFromReceipts(receipts);\n        return {\n          status: { type: 'success', programState: transaction.status.programState },\n          receipts,\n          transactionId: this.id,\n          blockId: transaction.status.block.id,\n          time: transaction.status.time,\n        };\n      }\n      default: {\n        throw new Error('Invalid Transaction status');\n      }\n    }\n  }\n\n  /** Waits for transaction to succeed and returns the result */\n  async wait(): Promise<TransactionResult<'success'>> {\n    const result = await this.waitForResult();\n\n    if (result.status.type === 'failure') {\n      throw new Error(`Transaction failed: ${result.status.reason}`);\n    }\n\n    return result;\n  }\n}\n","import { arrayify } from '@ethersproject/bytes';\nimport { StringCoder } from '@fuel-ts/abi-coder';\nimport { ReceiptType } from '@fuel-ts/transactions';\n\nimport type {\n  TransactionResultLogDataReceipt,\n  TransactionResultLogReceipt,\n  TransactionResultReceipt,\n} from './transaction-response';\n\ntype LogReceipt = TransactionResultLogReceipt | TransactionResultLogDataReceipt;\nclass LogReader {\n  logs: LogReceipt[];\n\n  constructor(receipts: TransactionResultReceipt[]) {\n    this.logs = receipts.filter(\n      ({ type }) => type === ReceiptType.Log || type === ReceiptType.LogData\n    ) as LogReceipt[];\n  }\n\n  toArray(): string[] {\n    return this.logs.map((log) => {\n      if (log.type === ReceiptType.LogData) {\n        const stringCoder = new StringCoder(Number(log.len));\n        let value = stringCoder.decode(arrayify(log.data), 0)[0];\n        value = value.replaceAll('\\x00', '');\n        return `${value}`;\n      }\n\n      return `${log.val0}`;\n    });\n  }\n\n  print(): string {\n    return this.toArray()\n      .map((log, id) => `[log ${id}] ${log}`)\n      .join('\\n');\n  }\n\n  toString(): string {\n    return this.print();\n  }\n\n  static debug(receipts: TransactionResultReceipt[]) {\n    const logReader = new LogReader(receipts);\n    // eslint-disable-next-line no-console\n    console.log(logReader.print());\n  }\n}\n\nexport default LogReader;\n"],"mappings":"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","names":["src_exports","__export","ChangeOutputCollisionError","GqlCoinStatus","CreateTransactionRequest","LogReader_default","NoWitnessAtIndexError","NoWitnessByOwnerError","Provider","ScriptTransactionRequest","TransactionResponse","calculatePriceWithFactor","coinQuantityfy","getGasUsedFromReceipts","getSignableTransaction","getTransactionId","inputify","outputify","returnZeroScript","transactionRequestify","__toCommonJS","import_bytes","import_constants","import_math","coinQuantityfy","coinQuantityLike","_a","_b","assetId","amount","import_graphql_tag","GqlCoinStatus","TransactionFragmentFragmentDoc","gql","ReceiptFragmentFragmentDoc","CoinFragmentFragmentDoc","BalanceFragmentFragmentDoc","BlockFragmentFragmentDoc","ChainInfoFragmentFragmentDoc","GetVersionDocument","GetInfoDocument","GetChainDocument","GetTransactionDocument","GetTransactionWithReceiptsDocument","GetTransactionsDocument","GetTransactionsByOwnerDocument","GetBlockDocument","GetBlockWithTransactionsDocument","GetBlocksDocument","GetCoinDocument","GetCoinsDocument","GetCoinsToSpendDocument","GetContractDocument","GetBalanceDocument","GetBalancesDocument","DryRunDocument","SubmitDocument","StartSessionDocument","EndSessionDocument","ExecuteDocument","ResetDocument","defaultWrapper","action","_operationName","_operationType","getSdk","client","withWrapper","variables","requestHeaders","wrappedRequestHeaders","import_bytes","import_abi_coder","import_constants","import_math","import_transactions","import_graphql_request","import_lodash","import_bytes","import_constants","import_math","import_transactions","inputify","value","_a","_b","_c","predicate","predicateData","import_bytes","import_constants","import_math","import_transactions","outputify","value","import_bytes","import_address","import_constants","import_math","import_transactions","import_sha2","import_constants","import_math","import_transactions","getSignableTransaction","transaction","signableTransaction","input","output","getTransactionId","encodedTransaction","calculatePriceWithFactor","gasUsed","gasPrice","priceFactor","getGasUsedFromReceipts","receipts","scriptResult","receipt","import_bytes","getStorageValue","value","v","storageSlotify","storageSlot","key","import_bytes","witnessify","value","data","returnZeroScript","ChangeOutputCollisionError","NoWitnessAtIndexError","index","NoWitnessByOwnerError","owner","BaseTransactionRequest","gasPrice","gasLimit","maturity","inputs","outputs","witnesses","_a","_b","_c","_d","_e","_f","inputify","outputify","witnessify","input","output","witness","ownerAddress","witnessIndex","coin","changeOutput","coins","to","amount","assetId","quantities","coinQuantityfy","quantity","witnessSize","total","w","gasFee","calculatePriceWithFactor","ScriptTransactionRequest","script","scriptData","rest","obj","data","numberOfVariables","outputsNumber","contract","contractAddress","i","inputIndex","CreateTransactionRequest","bytecodeWitnessIndex","salt","storageSlots","baseTransaction","storageSlotify","contractId","stateRoot","transactionRequestify","import_bytes","import_math","import_transactions","processGqlReceipt","gqlReceipt","receipt","_fetch","fetch_fn","TransactionResponse","id","request","provider","__privateAdd","_a","transaction","__privateMethod","receipts","getGasUsedFromReceipts","result","processGqlReceipt","gqlReceipt","receipt","processGqlChain","chain","i","processNodeInfo","nodeInfo","Provider","url","gqlClient","getSdk","nodeVersion","transactionRequestLike","transactionRequest","transactionRequestify","encodedTransaction","gasUsed","minGasPrice","transactionId","TransactionResponse","utxoValidation","gqlReceipts","tolerance","cloneDeep","gasPrice","margin","receipts","getGasUsedFromReceipts","gasFee","calculatePriceWithFactor","owner","assetId","paginationArgs","edge","coin","quantities","maxInputs","excludedIds","coinQuantityfy","quantity","id","idOrHeight","variables","block","tx","_a","transaction","contractId","contract","balance","predicate","amountToSpend","receiverAddress","predicateData","predicateOptions","walletAddress","predicateCoins","options","request","ScriptTransactionRequest","encoded","totalInPredicate","prev","requiredCoinQuantities","coins","error","message","import_bytes","import_abi_coder","import_transactions","LogReader","receipts","type","log","value","id","logReader","LogReader_default"]}