import { BytesLike } from '@ethersproject/bytes';
import { BigNumberish, BN } from '@fuel-ts/math';
import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import { Network } from '@ethersproject/networks';
import { InputValue } from '@fuel-ts/abi-coder';
import { AbstractScript, AbstractAddress, ContractIdLike, AddressLike, AbstractPredicate } from '@fuel-ts/interfaces';
import { InputType, Input, OutputType, Output, TransactionType, Transaction, ReceiptCall, ReceiptReturn, ReceiptReturnData, ReceiptPanic, ReceiptRevert, ReceiptLog, ReceiptLogData, ReceiptTransfer, ReceiptTransferOut, ReceiptScriptResult } from '@fuel-ts/transactions';
export { TransactionType } from '@fuel-ts/transactions';

declare type CoinQuantityLike = [amount: BigNumberish, assetId?: BytesLike] | {
    amount: BigNumberish;
    assetId?: BytesLike;
};
declare type CoinQuantity = {
    amount: BN;
    assetId: string;
};
declare const coinQuantityfy: (coinQuantityLike: CoinQuantityLike) => CoinQuantity;

declare type Maybe<T> = T | null;
declare type InputMaybe<T> = Maybe<T>;
declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
/** All built-in and custom scalars, mapped to their actual values */
declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    Address: string;
    AssetId: string;
    BlockId: string;
    Bytes32: string;
    ContractId: string;
    /**
     * Implement the DateTime<Utc> scalar
     *
     * The input/output is a string in RFC3339 format.
     */
    DateTime: string;
    HexString: string;
    MessageId: any;
    Salt: string;
    TransactionId: string;
    TxPointer: any;
    U64: string;
    UtxoId: string;
};
declare type GqlBalanceFilterInput = {
    /** Filter coins based on the `owner` field */
    owner: Scalars['Address'];
};
declare type GqlCoinFilterInput = {
    /** Asset ID of the coins */
    assetId?: InputMaybe<Scalars['AssetId']>;
    /** Address of the owner */
    owner: Scalars['Address'];
};
declare enum GqlCoinStatus {
    Spent = "SPENT",
    Unspent = "UNSPENT"
}
declare enum GqlReturnType {
    Return = "RETURN",
    ReturnData = "RETURN_DATA",
    Revert = "REVERT"
}
declare type GqlSpendQueryElementInput = {
    /** Target amount for the query */
    amount: Scalars['U64'];
    /** Asset ID of the coins */
    assetId: Scalars['AssetId'];
};
declare type GqlGetVersionQueryVariables = Exact<{
    [key: string]: never;
}>;
declare type GqlGetVersionQuery = {
    __typename: 'Query';
    nodeInfo: {
        __typename: 'NodeInfo';
        nodeVersion: string;
    };
};
declare type GqlGetInfoQueryVariables = Exact<{
    [key: string]: never;
}>;
declare type GqlGetInfoQuery = {
    __typename: 'Query';
    nodeInfo: {
        __typename: 'NodeInfo';
        nodeVersion: string;
        minGasPrice: string;
    };
};
declare type GqlGetChainQueryVariables = Exact<{
    [key: string]: never;
}>;
declare type GqlGetChainQuery = {
    __typename: 'Query';
    chain: {
        __typename: 'ChainInfo';
        name: string;
        baseChainHeight: string;
        peerCount: number;
        consensusParameters: {
            __typename: 'ConsensusParameters';
            gasPriceFactor: string;
            maxGasPerTx: string;
            maxScriptLength: string;
        };
        latestBlock: {
            __typename: 'Block';
            id: string;
            height: string;
            producer: string;
            time: string;
            transactions: Array<{
                __typename: 'Transaction';
                id: string;
            }>;
        };
    };
};
declare type GqlGetTransactionQueryVariables = Exact<{
    transactionId: Scalars['TransactionId'];
}>;
declare type GqlGetTransactionQuery = {
    __typename: 'Query';
    transaction?: {
        __typename: 'Transaction';
        id: string;
        rawPayload: string;
        status?: {
            __typename: 'FailureStatus';
            time: string;
            reason: string;
            type: 'FailureStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
        } | {
            __typename: 'SubmittedStatus';
            time: string;
            type: 'SubmittedStatus';
        } | {
            __typename: 'SuccessStatus';
            time: string;
            type: 'SuccessStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
            programState: {
                __typename: 'ProgramState';
                returnType: GqlReturnType;
                data: string;
            };
        } | null;
    } | null;
};
declare type GqlGetTransactionWithReceiptsQueryVariables = Exact<{
    transactionId: Scalars['TransactionId'];
}>;
declare type GqlGetTransactionWithReceiptsQuery = {
    __typename: 'Query';
    transaction?: {
        __typename: 'Transaction';
        id: string;
        rawPayload: string;
        receipts?: Array<{
            __typename: 'Receipt';
            data?: string | null;
            rawPayload: string;
        }> | null;
        status?: {
            __typename: 'FailureStatus';
            time: string;
            reason: string;
            type: 'FailureStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
        } | {
            __typename: 'SubmittedStatus';
            time: string;
            type: 'SubmittedStatus';
        } | {
            __typename: 'SuccessStatus';
            time: string;
            type: 'SuccessStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
            programState: {
                __typename: 'ProgramState';
                returnType: GqlReturnType;
                data: string;
            };
        } | null;
    } | null;
};
declare type GqlGetTransactionsQueryVariables = Exact<{
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetTransactionsQuery = {
    __typename: 'Query';
    transactions: {
        __typename: 'TransactionConnection';
        edges: Array<{
            __typename: 'TransactionEdge';
            node: {
                __typename: 'Transaction';
                id: string;
                rawPayload: string;
                status?: {
                    __typename: 'FailureStatus';
                    time: string;
                    reason: string;
                    type: 'FailureStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                } | {
                    __typename: 'SubmittedStatus';
                    time: string;
                    type: 'SubmittedStatus';
                } | {
                    __typename: 'SuccessStatus';
                    time: string;
                    type: 'SuccessStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                    programState: {
                        __typename: 'ProgramState';
                        returnType: GqlReturnType;
                        data: string;
                    };
                } | null;
            };
        }>;
    };
};
declare type GqlGetTransactionsByOwnerQueryVariables = Exact<{
    owner: Scalars['Address'];
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetTransactionsByOwnerQuery = {
    __typename: 'Query';
    transactionsByOwner: {
        __typename: 'TransactionConnection';
        edges: Array<{
            __typename: 'TransactionEdge';
            node: {
                __typename: 'Transaction';
                id: string;
                rawPayload: string;
                status?: {
                    __typename: 'FailureStatus';
                    time: string;
                    reason: string;
                    type: 'FailureStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                } | {
                    __typename: 'SubmittedStatus';
                    time: string;
                    type: 'SubmittedStatus';
                } | {
                    __typename: 'SuccessStatus';
                    time: string;
                    type: 'SuccessStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                    programState: {
                        __typename: 'ProgramState';
                        returnType: GqlReturnType;
                        data: string;
                    };
                } | null;
            };
        }>;
    };
};
declare type GqlGetBlockQueryVariables = Exact<{
    blockId?: InputMaybe<Scalars['BlockId']>;
    blockHeight?: InputMaybe<Scalars['U64']>;
}>;
declare type GqlGetBlockQuery = {
    __typename: 'Query';
    block?: {
        __typename: 'Block';
        id: string;
        height: string;
        producer: string;
        time: string;
        transactions: Array<{
            __typename: 'Transaction';
            id: string;
        }>;
    } | null;
};
declare type GqlGetBlockWithTransactionsQueryVariables = Exact<{
    blockId?: InputMaybe<Scalars['BlockId']>;
    blockHeight?: InputMaybe<Scalars['U64']>;
}>;
declare type GqlGetBlockWithTransactionsQuery = {
    __typename: 'Query';
    block?: {
        __typename: 'Block';
        id: string;
        height: string;
        producer: string;
        time: string;
        transactions: Array<{
            __typename: 'Transaction';
            id: string;
            rawPayload: string;
            status?: {
                __typename: 'FailureStatus';
                time: string;
                reason: string;
                type: 'FailureStatus';
                block: {
                    __typename: 'Block';
                    id: string;
                };
            } | {
                __typename: 'SubmittedStatus';
                time: string;
                type: 'SubmittedStatus';
            } | {
                __typename: 'SuccessStatus';
                time: string;
                type: 'SuccessStatus';
                block: {
                    __typename: 'Block';
                    id: string;
                };
                programState: {
                    __typename: 'ProgramState';
                    returnType: GqlReturnType;
                    data: string;
                };
            } | null;
        }>;
    } | null;
};
declare type GqlGetBlocksQueryVariables = Exact<{
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetBlocksQuery = {
    __typename: 'Query';
    blocks: {
        __typename: 'BlockConnection';
        edges: Array<{
            __typename: 'BlockEdge';
            node: {
                __typename: 'Block';
                id: string;
                height: string;
                producer: string;
                time: string;
                transactions: Array<{
                    __typename: 'Transaction';
                    id: string;
                }>;
            };
        }>;
    };
};
declare type GqlGetCoinQueryVariables = Exact<{
    coinId: Scalars['UtxoId'];
}>;
declare type GqlGetCoinQuery = {
    __typename: 'Query';
    coin?: {
        __typename: 'Coin';
        utxoId: string;
        owner: string;
        amount: string;
        assetId: string;
        maturity: string;
        status: GqlCoinStatus;
        blockCreated: string;
    } | null;
};
declare type GqlGetCoinsQueryVariables = Exact<{
    filter: GqlCoinFilterInput;
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetCoinsQuery = {
    __typename: 'Query';
    coins: {
        __typename: 'CoinConnection';
        edges: Array<{
            __typename: 'CoinEdge';
            node: {
                __typename: 'Coin';
                utxoId: string;
                owner: string;
                amount: string;
                assetId: string;
                maturity: string;
                status: GqlCoinStatus;
                blockCreated: string;
            };
        }>;
    };
};
declare type GqlGetCoinsToSpendQueryVariables = Exact<{
    owner: Scalars['Address'];
    spendQuery: Array<GqlSpendQueryElementInput> | GqlSpendQueryElementInput;
    maxInputs?: InputMaybe<Scalars['Int']>;
    excludedIds?: InputMaybe<Array<Scalars['UtxoId']> | Scalars['UtxoId']>;
}>;
declare type GqlGetCoinsToSpendQuery = {
    __typename: 'Query';
    coinsToSpend: Array<{
        __typename: 'Coin';
        utxoId: string;
        owner: string;
        amount: string;
        assetId: string;
        maturity: string;
        status: GqlCoinStatus;
        blockCreated: string;
    }>;
};
declare type GqlGetContractQueryVariables = Exact<{
    contractId: Scalars['ContractId'];
}>;
declare type GqlGetContractQuery = {
    __typename: 'Query';
    contract?: {
        __typename: 'Contract';
        bytecode: string;
        id: string;
    } | null;
};
declare type GqlGetBalanceQueryVariables = Exact<{
    owner: Scalars['Address'];
    assetId: Scalars['AssetId'];
}>;
declare type GqlGetBalanceQuery = {
    __typename: 'Query';
    balance: {
        __typename: 'Balance';
        owner: string;
        amount: string;
        assetId: string;
    };
};
declare type GqlGetBalancesQueryVariables = Exact<{
    filter: GqlBalanceFilterInput;
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetBalancesQuery = {
    __typename: 'Query';
    balances: {
        __typename: 'BalanceConnection';
        edges: Array<{
            __typename: 'BalanceEdge';
            node: {
                __typename: 'Balance';
                owner: string;
                amount: string;
                assetId: string;
            };
        }>;
    };
};
declare type GqlDryRunMutationVariables = Exact<{
    encodedTransaction: Scalars['HexString'];
    utxoValidation?: InputMaybe<Scalars['Boolean']>;
}>;
declare type GqlDryRunMutation = {
    __typename: 'Mutation';
    dryRun: Array<{
        __typename: 'Receipt';
        data?: string | null;
        rawPayload: string;
    }>;
};
declare type GqlSubmitMutationVariables = Exact<{
    encodedTransaction: Scalars['HexString'];
}>;
declare type GqlSubmitMutation = {
    __typename: 'Mutation';
    submit: {
        __typename: 'Transaction';
        id: string;
    };
};
declare type GqlStartSessionMutationVariables = Exact<{
    [key: string]: never;
}>;
declare type GqlStartSessionMutation = {
    __typename: 'Mutation';
    startSession: string;
};
declare type GqlEndSessionMutationVariables = Exact<{
    sessionId: Scalars['ID'];
}>;
declare type GqlEndSessionMutation = {
    __typename: 'Mutation';
    endSession: boolean;
};
declare type GqlExecuteMutationVariables = Exact<{
    sessionId: Scalars['ID'];
    op: Scalars['String'];
}>;
declare type GqlExecuteMutation = {
    __typename: 'Mutation';
    execute: boolean;
};
declare type GqlResetMutationVariables = Exact<{
    sessionId: Scalars['ID'];
}>;
declare type GqlResetMutation = {
    __typename: 'Mutation';
    reset: boolean;
};
declare type SdkFunctionWrapper = <T>(action: (requestHeaders?: Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;
declare function getSdk(client: GraphQLClient, withWrapper?: SdkFunctionWrapper): {
    getVersion(variables?: GqlGetVersionQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetVersionQuery>;
    getInfo(variables?: GqlGetInfoQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetInfoQuery>;
    getChain(variables?: GqlGetChainQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetChainQuery>;
    getTransaction(variables: GqlGetTransactionQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionQuery>;
    getTransactionWithReceipts(variables: GqlGetTransactionWithReceiptsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionWithReceiptsQuery>;
    getTransactions(variables?: GqlGetTransactionsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionsQuery>;
    getTransactionsByOwner(variables: GqlGetTransactionsByOwnerQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionsByOwnerQuery>;
    getBlock(variables?: GqlGetBlockQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBlockQuery>;
    getBlockWithTransactions(variables?: GqlGetBlockWithTransactionsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBlockWithTransactionsQuery>;
    getBlocks(variables?: GqlGetBlocksQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBlocksQuery>;
    getCoin(variables: GqlGetCoinQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetCoinQuery>;
    getCoins(variables: GqlGetCoinsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetCoinsQuery>;
    getCoinsToSpend(variables: GqlGetCoinsToSpendQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetCoinsToSpendQuery>;
    getContract(variables: GqlGetContractQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetContractQuery>;
    getBalance(variables: GqlGetBalanceQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBalanceQuery>;
    getBalances(variables: GqlGetBalancesQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBalancesQuery>;
    dryRun(variables: GqlDryRunMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlDryRunMutation>;
    submit(variables: GqlSubmitMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlSubmitMutation>;
    startSession(variables?: GqlStartSessionMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlStartSessionMutation>;
    endSession(variables: GqlEndSessionMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlEndSessionMutation>;
    execute(variables: GqlExecuteMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlExecuteMutation>;
    reset(variables: GqlResetMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlResetMutation>;
};

/**
 * A Fuel coin
 */
declare type Coin = {
    id: string;
    assetId: string;
    amount: BN;
    owner: string;
    status: GqlCoinStatus;
    maturity: number;
    blockCreated: BN;
};

declare type CoinTransactionRequestInput = {
    type: InputType.Coin;
    /** UTXO ID */
    id: BytesLike;
    /** Owning address or script hash */
    owner: BytesLike;
    /** Amount of coins */
    amount: BigNumberish;
    /** Asset ID of the coins */
    assetId: BytesLike;
    /** Points to the TX whose output is being spent. (TxPointer) */
    txPointer: BytesLike;
    /** Index of witness that authorizes spending the coin */
    witnessIndex: number;
    /** UTXO being spent must have been created at least this many blocks ago */
    maturity?: number;
    /** Predicate bytecode */
    predicate?: BytesLike;
    /** Predicate input data (parameters) */
    predicateData?: BytesLike;
};
declare type ContractTransactionRequestInput = {
    type: InputType.Contract;
    /** Points to the TX whose output is being spent. (TxPointer) */
    txPointer: BytesLike;
    /** Contract ID */
    contractId: BytesLike;
};
declare type TransactionRequestInput = CoinTransactionRequestInput | ContractTransactionRequestInput;
declare const inputify: (value: TransactionRequestInput) => Input;

declare type CoinTransactionRequestOutput = {
    type: OutputType.Coin;
    /** Receiving address or script hash */
    to: BytesLike;
    /** Amount of coins to send */
    amount: BigNumberish;
    /** Asset ID of coins */
    assetId: BytesLike;
};
declare type ContractTransactionRequestOutput = {
    type: OutputType.Contract;
    /** Index of input contract */
    inputIndex: number;
};
declare type WithdrawalTransactionRequestOutput = {
    type: OutputType.Withdrawal;
    /** Receiving address */
    to: BytesLike;
    /** Amount of coins to withdraw */
    amount: BigNumberish;
    /** Asset ID of coins */
    assetId: BytesLike;
};
declare type ChangeTransactionRequestOutput = {
    type: OutputType.Change;
    /** Receiving address or script hash */
    to: BytesLike;
    /** Asset ID of coins */
    assetId: BytesLike;
};
declare type VariableTransactionRequestOutput = {
    type: OutputType.Variable;
};
declare type ContractCreatedTransactionRequestOutput = {
    type: OutputType.ContractCreated;
    /** Contract ID */
    contractId: BytesLike;
    /** State Root */
    stateRoot: BytesLike;
};
declare type TransactionRequestOutput = CoinTransactionRequestOutput | ContractTransactionRequestOutput | WithdrawalTransactionRequestOutput | ChangeTransactionRequestOutput | VariableTransactionRequestOutput | ContractCreatedTransactionRequestOutput;
declare const outputify: (value: TransactionRequestOutput) => Output;

declare type TransactionRequestStorageSlot = {
    /** Key */
    key: BytesLike;
    /** Value */
    value: BytesLike;
} | [key: BytesLike, value: BytesLike];

declare type TransactionRequestWitness = BytesLike;

declare const returnZeroScript: AbstractScript<void>;
interface BaseTransactionRequestLike {
    /** Gas price for transaction */
    gasPrice?: BigNumberish;
    /** Gas limit for transaction */
    gasLimit?: BigNumberish;
    /** Block until which tx cannot be included */
    maturity?: number;
    /** List of inputs */
    inputs?: TransactionRequestInput[];
    /** List of outputs */
    outputs?: TransactionRequestOutput[];
    /** List of witnesses */
    witnesses?: TransactionRequestWitness[];
}
declare class ChangeOutputCollisionError extends Error {
    name: string;
    message: string;
}
declare class NoWitnessAtIndexError extends Error {
    readonly index: number;
    name: string;
    constructor(index: number);
}
declare class NoWitnessByOwnerError extends Error {
    readonly owner: AbstractAddress;
    name: string;
    constructor(owner: AbstractAddress);
}
declare abstract class BaseTransactionRequest implements BaseTransactionRequestLike {
    /** Type of the transaction */
    abstract type: TransactionType;
    /** Gas price for transaction */
    gasPrice: BN;
    /** Gas limit for transaction */
    gasLimit: BN;
    /** Block until which tx cannot be included */
    maturity: number;
    /** List of inputs */
    inputs: TransactionRequestInput[];
    /** List of outputs */
    outputs: TransactionRequestOutput[];
    /** List of witnesses */
    witnesses: TransactionRequestWitness[];
    constructor({ gasPrice, gasLimit, maturity, inputs, outputs, witnesses, }?: BaseTransactionRequestLike);
    protected getBaseTransaction(): Pick<Transaction, keyof BaseTransactionRequestLike | 'inputsCount' | 'outputsCount' | 'witnessesCount'>;
    abstract toTransaction(): Transaction;
    toTransactionBytes(): Uint8Array;
    /**
     * Pushes an input to the list without any side effects and returns the index
     */
    protected pushInput(input: TransactionRequestInput): number;
    /**
     * Pushes an output to the list without any side effects and returns the index
     */
    protected pushOutput(output: TransactionRequestOutput): number;
    /**
     * Creates an empty witness without any side effects and returns the index
     */
    protected createWitness(): number;
    /**
     * Updates an existing witness without any side effects
     */
    updateWitness(index: number, witness: TransactionRequestWitness): void;
    getCoinInputs(): CoinTransactionRequestInput[];
    getCoinOutputs(): CoinTransactionRequestOutput[];
    getChangeOutputs(): ChangeTransactionRequestOutput[];
    /**
     * Returns the witnessIndex of the found CoinInput
     */
    getCoinInputWitnessIndexByOwner(owner: AddressLike): number | null;
    /**
     * Updates the witness for the given CoinInput owner
     */
    updateWitnessByCoinInputOwner(owner: AddressLike, witness: BytesLike): void;
    /**
     * Converts the given Coin to a CoinInput with the appropriate witnessIndex and pushes it
     */
    addCoin(coin: Coin): void;
    addCoins(coins: ReadonlyArray<Coin>): void;
    addCoinOutput(
    /** Address of the destination */
    to: AddressLike, 
    /** Amount of coins */
    amount: BigNumberish, 
    /** Asset ID of coins */
    assetId?: BytesLike): void;
    addCoinOutputs(
    /** Address of the destination */
    to: AddressLike, 
    /** Quantities of coins */
    quantities: CoinQuantityLike[]): void;
    byteSize(): number;
    chargeableByteSize(): BN;
    /**
     * Return the minimum amount in native coins required to create
     * a transaction.
     *
     * Note: this is required even gasPrice = 0
     */
    calculateFee(): CoinQuantity;
}
interface ScriptTransactionRequestLike extends BaseTransactionRequestLike {
    /** Script to execute */
    script?: BytesLike;
    /** Script input data (parameters) */
    scriptData?: BytesLike;
}
declare class ScriptTransactionRequest extends BaseTransactionRequest {
    static from(obj: ScriptTransactionRequestLike): ScriptTransactionRequest;
    /** Type of the transaction */
    type: TransactionType.Script;
    /** Script to execute */
    script: Uint8Array;
    /** Script input data (parameters) */
    scriptData: Uint8Array;
    /** determined bytes offset for start of script data */
    bytesOffset: number | undefined;
    constructor({ script, scriptData, ...rest }?: ScriptTransactionRequestLike);
    toTransaction(): Transaction;
    getContractInputs(): ContractTransactionRequestInput[];
    getContractOutputs(): ContractTransactionRequestOutput[];
    getVariableOutputs(): VariableTransactionRequestOutput[];
    setScript<T>(script: AbstractScript<T>, data: T): void;
    addVariableOutputs(numberOfVariables?: number): number;
    addContract(contract: ContractIdLike): void;
}
interface CreateTransactionRequestLike extends BaseTransactionRequestLike {
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex?: number;
    /** Salt */
    salt?: BytesLike;
    /** List of storage slots to initialize */
    storageSlots?: TransactionRequestStorageSlot[];
}
declare class CreateTransactionRequest extends BaseTransactionRequest {
    static from(obj: CreateTransactionRequestLike): CreateTransactionRequest;
    /** Type of the transaction */
    type: TransactionType.Create;
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex: number;
    /** Salt */
    salt: string;
    /** List of storage slots to initialize */
    storageSlots: TransactionRequestStorageSlot[];
    constructor({ bytecodeWitnessIndex, salt, storageSlots, ...rest }?: CreateTransactionRequestLike);
    toTransaction(): Transaction;
    getContractCreatedOutputs(): ContractCreatedTransactionRequestOutput[];
    addContractCreatedOutput(
    /** Contract ID */
    contractId: BytesLike, 
    /** State Root */
    stateRoot: BytesLike): void;
}
declare type TransactionRequest = ScriptTransactionRequest | CreateTransactionRequest;
declare type TransactionRequestLike = ({
    type: TransactionType.Script;
} & ScriptTransactionRequestLike) | ({
    type: TransactionType.Create;
} & CreateTransactionRequestLike);
declare const transactionRequestify: (obj: TransactionRequestLike) => TransactionRequest;

declare type TransactionResultCallReceipt = ReceiptCall;
declare type TransactionResultReturnReceipt = ReceiptReturn;
declare type TransactionResultReturnDataReceipt = ReceiptReturnData & {
    data: string;
};
declare type TransactionResultPanicReceipt = ReceiptPanic;
declare type TransactionResultRevertReceipt = ReceiptRevert;
declare type TransactionResultLogReceipt = ReceiptLog;
declare type TransactionResultLogDataReceipt = ReceiptLogData & {
    data: string;
};
declare type TransactionResultTransferReceipt = ReceiptTransfer;
declare type TransactionResultTransferOutReceipt = ReceiptTransferOut;
declare type TransactionResultScriptResultReceipt = ReceiptScriptResult;
declare type TransactionResultReceipt = TransactionResultCallReceipt | TransactionResultReturnReceipt | TransactionResultReturnDataReceipt | TransactionResultPanicReceipt | TransactionResultRevertReceipt | TransactionResultLogReceipt | TransactionResultLogDataReceipt | TransactionResultTransferReceipt | TransactionResultTransferOutReceipt | TransactionResultScriptResultReceipt;
declare type TransactionResult<TStatus extends 'success' | 'failure'> = {
    status: TStatus extends 'success' ? {
        type: 'success';
        programState: any;
    } : {
        type: 'failure';
        reason: any;
    };
    /** Receipts produced during the execution of the transaction */
    receipts: TransactionResultReceipt[];
    transactionId: string;
    blockId: any;
    time: any;
};
declare class TransactionResponse {
    #private;
    /** Transaction ID */
    id: string;
    /** Transaction request */
    request: TransactionRequest;
    provider: Provider;
    /** Gas used on the transaction */
    gasUsed: BN;
    constructor(id: string, request: TransactionRequest, provider: Provider);
    /** Waits for transaction to succeed or fail and returns the result */
    waitForResult(): Promise<TransactionResult<any>>;
    /** Waits for transaction to succeed and returns the result */
    wait(): Promise<TransactionResult<'success'>>;
}

declare type CallResult = {
    receipts: TransactionResultReceipt[];
};
/**
 * A Fuel block
 */
declare type Block = {
    id: string;
    height: BN;
    time: string;
    producer: string;
    transactionIds: string[];
};
/**
 * Deployed Contract bytecode and contract id
 */
declare type ContractResult = {
    id: string;
    bytecode: string;
};
/**
 * Chain information
 */
declare type ChainInfo = {
    name: string;
    baseChainHeight: BN;
    peerCount: number;
    consensusParameters: {
        gasPriceFactor: BN;
        maxGasPerTx: BN;
        maxScriptLength: BN;
    };
    latestBlock: {
        id: string;
        height: BN;
        producer: string;
        time: string;
        transactions: Array<{
            id: string;
        }>;
    };
};
/**
 * Node information
 */
declare type NodeInfo = {
    minGasPrice: BN;
    nodeVersion: string;
};
declare type TransactionCost = {
    minGasPrice: BN;
    gasPrice: BN;
    gasUsed: BN;
    fee: BN;
};
/**
 * Cursor pagination arguments
 *
 * https://relay.dev/graphql/connections.htm#sec-Arguments
 */
declare type CursorPaginationArgs = {
    /** Forward pagination limit */
    first?: number | null;
    /** Forward pagination cursor */
    after?: string | null;
    /** Backward pagination limit  */
    last?: number | null;
    /** Backward pagination cursor */
    before?: string | null;
};
declare type BuildPredicateOptions = {
    fundTransaction?: boolean;
} & Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'>;
/**
 * Provider Call transaction params
 */
declare type ProviderCallParams = {
    utxoValidation?: boolean;
};
/**
 * A provider for connecting to a Fuel node
 */
declare class Provider {
    /** GraphQL endpoint of the Fuel node */
    url: string;
    operations: ReturnType<typeof getSdk>;
    constructor(
    /** GraphQL endpoint of the Fuel node */
    url: string);
    /**
     * Returns the version of the connected Fuel node
     */
    getVersion(): Promise<string>;
    /**
     * Returns the network configuration of the connected Fuel node
     */
    getNetwork(): Promise<Network>;
    /**
     * Returns the current block number
     */
    getBlockNumber(): Promise<BN>;
    /**
     * Returns node information
     */
    getNodeInfo(): Promise<NodeInfo>;
    /**
     * Returns chain information
     */
    getChain(): Promise<ChainInfo>;
    /**
     * Submits a transaction to the chain to be executed
     */
    sendTransaction(transactionRequestLike: TransactionRequestLike): Promise<TransactionResponse>;
    /**
     * Executes a transaction without actually submitting it to the chain
     */
    call(transactionRequestLike: TransactionRequestLike, { utxoValidation }?: ProviderCallParams): Promise<CallResult>;
    /**
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the the transaction.
     *
     * The tolerance is add on top of the gasUsed calculated
     * from the node, this create a safe margin costs like
     * change states on transfer that don't occur on the dryRun
     * transaction. The default value is 0.2 or 20%
     */
    getTransactionCost(transactionRequestLike: TransactionRequestLike, tolerance?: number): Promise<TransactionCost>;
    /**
     * Returns coins for the given owner
     */
    getCoins(
    /** The address to get coins for */
    owner: AbstractAddress, 
    /** The asset ID of coins to get */
    assetId?: BytesLike, 
    /** Pagination arguments */
    paginationArgs?: CursorPaginationArgs): Promise<Coin[]>;
    /**
     * Returns coins for the given owner satisfying the spend query
     */
    getCoinsToSpend(
    /** The address to get coins for */
    owner: AbstractAddress, 
    /** The quantitites to get */
    quantities: CoinQuantityLike[], 
    /** Maximum number of coins to return */
    maxInputs?: number, 
    /** IDs of coins to exclude */
    excludedIds?: BytesLike[]): Promise<Coin[]>;
    /**
     * Returns block matching the given ID or type
     */
    getBlock(
    /** ID or height of the block */
    idOrHeight: string | number | 'latest'): Promise<Block | null>;
    /**
     * Returns block matching the given ID or type, including transaction data
     */
    getBlockWithTransactions(
    /** ID or height of the block */
    idOrHeight: string | number | 'latest'): Promise<(Block & {
        transactions: Transaction[];
    }) | null>;
    /**
     * Get transaction with the given ID
     */
    getTransaction(transactionId: string): Promise<Transaction | null>;
    /**
     * Get deployed contract with the given ID
     *
     * @returns contract bytecode and contract id
     */
    getContract(contractId: string): Promise<ContractResult | null>;
    /**
     * Returns the balance for the given owner for the given asset ID
     */
    getBalance(
    /** The address to get coins for */
    owner: AbstractAddress, 
    /** The asset ID of coins to get */
    assetId: BytesLike): Promise<BN>;
    /**
     * Returns balances for the given owner
     */
    getBalances(
    /** The address to get coins for */
    owner: AbstractAddress, 
    /** Pagination arguments */
    paginationArgs?: CursorPaginationArgs): Promise<CoinQuantity[]>;
    buildSpendPredicate(predicate: AbstractPredicate, amountToSpend: BigNumberish, receiverAddress: AbstractAddress, predicateData?: InputValue[], assetId?: BytesLike, predicateOptions?: BuildPredicateOptions, walletAddress?: AbstractAddress): Promise<ScriptTransactionRequest>;
    submitSpendPredicate(predicate: AbstractPredicate, amountToSpend: BigNumberish, receiverAddress: AbstractAddress, predicateData?: InputValue[], assetId?: BytesLike, options?: BuildPredicateOptions, walletAddress?: AbstractAddress): Promise<TransactionResult<'success'>>;
}

declare const getSignableTransaction: (transaction: Transaction) => Transaction;
declare const getTransactionId: (transaction: Transaction) => string;
declare const calculatePriceWithFactor: (gasUsed: BN, gasPrice: BN, priceFactor: BN) => BN;
declare const getGasUsedFromReceipts: (receipts: Array<TransactionResultReceipt>) => BN;

declare type LogReceipt = TransactionResultLogReceipt | TransactionResultLogDataReceipt;
declare class LogReader {
    logs: LogReceipt[];
    constructor(receipts: TransactionResultReceipt[]);
    toArray(): string[];
    print(): string;
    toString(): string;
    static debug(receipts: TransactionResultReceipt[]): void;
}

export { Block, BuildPredicateOptions, CallResult, ChainInfo, ChangeOutputCollisionError, ChangeTransactionRequestOutput, Coin, CoinQuantity, CoinQuantityLike, GqlCoinStatus as CoinStatus, CoinTransactionRequestInput, CoinTransactionRequestOutput, ContractCreatedTransactionRequestOutput, ContractResult, ContractTransactionRequestInput, ContractTransactionRequestOutput, CreateTransactionRequest, CreateTransactionRequestLike, CursorPaginationArgs, LogReader, NoWitnessAtIndexError, NoWitnessByOwnerError, NodeInfo, Provider, ProviderCallParams, ScriptTransactionRequest, ScriptTransactionRequestLike, TransactionCost, TransactionRequest, TransactionRequestInput, TransactionRequestLike, TransactionRequestOutput, TransactionResponse, TransactionResult, TransactionResultCallReceipt, TransactionResultLogDataReceipt, TransactionResultLogReceipt, TransactionResultPanicReceipt, TransactionResultReceipt, TransactionResultReturnDataReceipt, TransactionResultReturnReceipt, TransactionResultRevertReceipt, TransactionResultScriptResultReceipt, TransactionResultTransferOutReceipt, TransactionResultTransferReceipt, VariableTransactionRequestOutput, WithdrawalTransactionRequestOutput, calculatePriceWithFactor, coinQuantityfy, getGasUsedFromReceipts, getSignableTransaction, getTransactionId, inputify, outputify, returnZeroScript, transactionRequestify };
