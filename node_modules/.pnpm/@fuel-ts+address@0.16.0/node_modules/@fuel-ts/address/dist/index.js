"use strict";var a=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var L=Object.getOwnPropertyNames;var R=Object.prototype.hasOwnProperty;var U=(r,t)=>{for(var e in t)a(r,e,{get:t[e],enumerable:!0})},O=(r,t,e,h)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of L(t))!R.call(r,n)&&n!==e&&a(r,n,{get:()=>t[n],enumerable:!(h=E(t,n))||h.enumerable});return r};var v=r=>O(a({},"__esModule",{value:!0}),r);var F={};U(F,{Address:()=>s,FUEL_BECH32_HRP_PREFIX:()=>c,addressify:()=>D,fromBech32:()=>f,getBytesFromBech32:()=>m,getRandomB256:()=>g,isBech32:()=>i,normalizeBech32:()=>p,toB256:()=>u,toBech32:()=>B});module.exports=v(F);var d=require("@ethersproject/bytes"),y=require("@ethersproject/logger"),A=require("@fuel-ts/interfaces"),l=require("@fuel-ts/keystore"),o=require("bech32"),C=new y.Logger(process.env.BUILD_VERSION||"~"),c="fuel";function f(r){return o.bech32m.decode(r)}function B(r){return o.bech32m.encode(c,o.bech32m.toWords((0,d.arrayify)((0,d.hexlify)(r))))}function i(r){return typeof r=="string"&&r.indexOf(c+1)===0&&f(r).prefix===c}function m(r){return new Uint8Array(o.bech32m.fromWords(f(r).words))}function u(r){return i(r)||C.throwArgumentError("Invalid Bech32 Address","address",r),(0,d.hexlify)(m(r))}function p(r){let{words:t}=f(r);return o.bech32m.encode(c,t)}var D=r=>r instanceof A.AbstractWallet?r.address:r instanceof A.AbstractContract?r.id:r,g=()=>(0,d.hexlify)((0,l.randomBytes)(32));var w=require("@ethersproject/logger"),I=require("@ethersproject/sha2"),S=require("@fuel-ts/interfaces");var x=new w.Logger(process.env.BUILD_VERSION||"~"),s=class extends S.AbstractAddress{constructor(e){super();x.checkNew(new.target,s),this.bech32Address=p(e),i(this.bech32Address)||x.throwArgumentError("Invalid Bech32 Address","address",e)}toAddress(){return this.bech32Address}toB256(){return u(this.bech32Address)}toBytes(){return m(this.bech32Address)}toHexString(){return this.toB256()}toString(){return this.bech32Address}toJSON(){return this.toString()}equals(e){return this.bech32Address===e.bech32Address}static fromPublicKey(e){let h=(0,I.sha256)(e);return new s(B(h))}static fromB256(e){return new s(B(e))}static fromRandom(){return this.fromB256(g())}static fromString(e){return i(e)?new s(e):this.fromB256(e)}static fromAddressOrString(e){return typeof e=="string"?this.fromString(e):e}};0&&(module.exports={Address,FUEL_BECH32_HRP_PREFIX,addressify,fromBech32,getBytesFromBech32,getRandomB256,isBech32,normalizeBech32,toB256,toBech32});
//# sourceMappingURL=index.js.map