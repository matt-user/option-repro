import{arrayify as b,hexlify as n}from"@ethersproject/bytes";import{Logger as y}from"@ethersproject/logger";import{AbstractContract as l,AbstractWallet as x}from"@fuel-ts/interfaces";import{randomBytes as w}from"@fuel-ts/keystore";import{bech32m as s}from"bech32";var I=new y(process.env.BUILD_VERSION||"~"),o="fuel";function c(r){return s.decode(r)}function i(r){return s.encode(o,s.toWords(b(n(r))))}function d(r){return typeof r=="string"&&r.indexOf(o+1)===0&&c(r).prefix===o}function h(r){return new Uint8Array(s.fromWords(c(r).words))}function m(r){return d(r)||I.throwArgumentError("Invalid Bech32 Address","address",r),n(h(r))}function a(r){let{words:A}=c(r);return s.encode(o,A)}var D=r=>r instanceof x?r.address:r instanceof l?r.id:r,u=()=>n(w(32));import{Logger as S}from"@ethersproject/logger";import{sha256 as E}from"@ethersproject/sha2";import{AbstractAddress as L}from"@fuel-ts/interfaces";var p=new S(process.env.BUILD_VERSION||"~"),t=class extends L{constructor(e){super();p.checkNew(new.target,t),this.bech32Address=a(e),d(this.bech32Address)||p.throwArgumentError("Invalid Bech32 Address","address",e)}toAddress(){return this.bech32Address}toB256(){return m(this.bech32Address)}toBytes(){return h(this.bech32Address)}toHexString(){return this.toB256()}toString(){return this.bech32Address}toJSON(){return this.toString()}equals(e){return this.bech32Address===e.bech32Address}static fromPublicKey(e){let g=E(e);return new t(i(g))}static fromB256(e){return new t(i(e))}static fromRandom(){return this.fromB256(u())}static fromString(e){return d(e)?new t(e):this.fromB256(e)}static fromAddressOrString(e){return typeof e=="string"?this.fromString(e):e}};export{t as Address,o as FUEL_BECH32_HRP_PREFIX,D as addressify,c as fromBech32,h as getBytesFromBech32,u as getRandomB256,d as isBech32,a as normalizeBech32,m as toB256,i as toBech32};
//# sourceMappingURL=index.mjs.map