{"version":3,"sources":["../../../node_modules/.pnpm/tsup@5.12.9_s5ojjbx2isjkawqptqpitvy25q/node_modules/tsup/assets/esm_shims.js","../src/test-utils.ts","../../keystore/src/index.ts","../../keystore/src/keystore.ts","../../keystore/src/aes-ctr-node.ts","../../keystore/src/aes-ctr.ts","../../keystore/src/universal-crypto.ts","../../keystore/src/randomBytes.ts","../../keystore/src/aes-ctr-web.ts","../src/wallet.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport { fileURLToPath } from 'url'\nimport path from 'path'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","import { randomBytes } from '@fuel-ts/keystore';\nimport type { Provider, CoinQuantityLike } from '@fuel-ts/providers';\nimport { coinQuantityfy, ScriptTransactionRequest } from '@fuel-ts/providers';\n\nimport Wallet from './wallet';\n\nexport const seedWallet = async (wallet: Wallet, quantities: CoinQuantityLike[]) => {\n  const genesisWallet = new Wallet(process.env.GENESIS_SECRET || randomBytes(32), wallet.provider);\n  // Connect to the same Provider as wallet\n  const coins = await genesisWallet.getCoinsToSpend(quantities);\n  // Create transaction\n  const request = new ScriptTransactionRequest({\n    gasLimit: 10000,\n    gasPrice: 1,\n  });\n  request.addCoins(coins);\n  quantities\n    .map(coinQuantityfy)\n    .forEach(({ amount, assetId }) => request.addCoinOutput(wallet.address, amount, assetId));\n  const response = await genesisWallet.sendTransaction(request);\n\n  await response.wait();\n};\n\nexport const generateTestWallet = async (\n  provider: Provider,\n  quantities?: CoinQuantityLike[]\n): Promise<Wallet> => {\n  const wallet = Wallet.generate({ provider });\n  if (quantities) {\n    await seedWallet(wallet, quantities);\n  }\n  return wallet;\n};\n","export * from './keystore';\n","import type { Keystore } from './aes-ctr';\nimport { encrypt as encNode, decrypt as decNode } from './aes-ctr-node';\nimport { encrypt as encWeb, decrypt as decWeb } from './aes-ctr-web';\nimport { strategy } from './universal-crypto';\n\nexport type { Keystore } from './aes-ctr';\nexport { keyFromPassword } from './aes-ctr';\nexport { randomBytes } from './randomBytes';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> Keystore object\n */\nexport async function encrypt<T>(password: string, data: T): Promise<Keystore> {\n  return strategy === 'Node' ? encNode<T>(password, data) : encWeb<T>(password, data);\n}\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n *\n *  @returns Promise<T> T object\n */\nexport async function decrypt<T>(password: string, keystore: Keystore): Promise<T> {\n  return strategy === 'Node' ? decNode<T>(password, keystore) : decWeb<T>(password, keystore);\n}\n","import type { Keystore } from './aes-ctr';\nimport { bufferFromString, stringFromBuffer, keyFromPassword } from './aes-ctr';\nimport { randomBytes } from './randomBytes';\nimport { crypto } from './universal-crypto';\n\nconst ALGORITHM = 'aes-256-ctr';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> object\n */\nexport async function encrypt<T>(password: string, data: T): Promise<Keystore> {\n  const iv = randomBytes(16);\n  const salt = randomBytes(32);\n  const secret = keyFromPassword(password, salt);\n  const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), 'utf-8'));\n\n  const cipher = crypto.createCipheriv(ALGORITHM, secret, iv);\n  let cipherData = cipher.update(dataBuffer);\n  cipherData = Buffer.concat([cipherData, cipher.final()]);\n\n  return {\n    data: stringFromBuffer(cipherData),\n    iv: stringFromBuffer(iv),\n    salt: stringFromBuffer(salt),\n  };\n}\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n */\nexport async function decrypt<T>(password: string, keystore: Keystore): Promise<T> {\n  const iv = bufferFromString(keystore.iv);\n  const salt = bufferFromString(keystore.salt);\n  const secret = keyFromPassword(password, salt);\n  const encryptedText = bufferFromString(keystore.data);\n\n  const decipher = crypto.createDecipheriv(ALGORITHM, secret, iv);\n  const decrypted = decipher.update(encryptedText);\n  const deBuff = Buffer.concat([decrypted, decipher.final()]);\n  const decryptedData = Buffer.from(deBuff).toString('utf-8');\n\n  try {\n    return JSON.parse(decryptedData);\n  } catch {\n    throw new Error('Invalid credentials');\n  }\n}\n","import { arrayify } from '@ethersproject/bytes';\nimport { pbkdf2 } from '@ethersproject/pbkdf2';\n\nimport { strategy } from './universal-crypto';\n\nexport interface Keystore {\n  data: string;\n  iv: string;\n  salt: string;\n}\n\nexport function bufferFromString(\n  string: string,\n  encoding: 'utf-8' | 'base64' = 'base64'\n): Uint8Array {\n  if (strategy === 'Node') {\n    return Buffer.from(string, encoding);\n  }\n  if (encoding === 'utf-8') {\n    return new TextEncoder().encode(string);\n  }\n\n  return new Uint8Array(\n    atob(string)\n      .split('')\n      .map((c) => c.charCodeAt(0))\n  );\n}\n\nexport function stringFromBuffer(\n  buffer: Uint8Array,\n  encoding: 'utf-8' | 'base64' = 'base64'\n): string {\n  if (strategy === 'Node') {\n    return Buffer.from(buffer).toString(encoding);\n  }\n\n  return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer) as unknown as number[]));\n}\n\n/**\n * Generate a pbkdf2 key from a password and random salt\n */\nexport function keyFromPassword(password: string, saltBuffer: Uint8Array): Uint8Array {\n  const passBuffer = bufferFromString(String(password).normalize('NFKC'), 'utf-8');\n  const key = pbkdf2(passBuffer, saltBuffer, 100000, 32, 'sha256');\n\n  return arrayify(key);\n}\n","import type { createCipheriv, createDecipheriv } from 'crypto';\n\ntype UniversalCrypto = {\n  getRandomValues: (length: number) => Uint8Array;\n  randomBytes: (length: number) => Uint8Array;\n  subtle: SubtleCrypto;\n  createCipheriv: typeof createCipheriv;\n  createDecipheriv: typeof createDecipheriv;\n};\nlet selectedCrypto;\nlet selectedStrategy: 'Node' | 'Web' = 'Node';\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nif (typeof globalThis !== 'undefined' && globalThis.crypto) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  selectedCrypto = globalThis.crypto;\n  selectedStrategy = 'Web';\n}\n\nif (!selectedCrypto && typeof require === 'function') {\n  try {\n    // eslint-disable-next-line global-require\n    selectedCrypto = require('crypto');\n    selectedStrategy = 'Node';\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error('keystore expects a standard Web browser or Node environment.', error);\n  }\n}\n\nexport const crypto: UniversalCrypto = selectedCrypto;\nexport const strategy = selectedStrategy;\n","import { crypto, strategy } from './universal-crypto';\n\nexport const randomBytes = (length: number) =>\n  strategy === 'Node'\n    ? crypto.randomBytes(length)\n    : crypto.getRandomValues(new Uint8Array(length) as unknown as number);\n","import type { Keystore } from './aes-ctr';\nimport { bufferFromString, stringFromBuffer, keyFromPassword } from './aes-ctr';\nimport { randomBytes } from './randomBytes';\nimport { crypto } from './universal-crypto';\n\nconst ALGORITHM = 'AES-CTR';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> object\n */\nexport async function encrypt<T>(password: string, data: T): Promise<Keystore> {\n  const iv = randomBytes(16);\n  const salt = randomBytes(32);\n  const secret = keyFromPassword(password, salt);\n  const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), 'utf-8'));\n  const alg = {\n    name: ALGORITHM,\n    counter: iv,\n    length: 64,\n  };\n  const key = await crypto.subtle.importKey('raw', secret, alg, false, ['encrypt']);\n  const encBuffer = await crypto.subtle.encrypt(alg, key, dataBuffer);\n\n  return {\n    data: stringFromBuffer(encBuffer),\n    iv: stringFromBuffer(iv),\n    salt: stringFromBuffer(salt),\n  };\n}\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n */\nexport async function decrypt<T>(password: string, keystore: Keystore): Promise<T> {\n  const iv = bufferFromString(keystore.iv);\n  const salt = bufferFromString(keystore.salt);\n  const secret = keyFromPassword(password, salt);\n  const encryptedText = bufferFromString(keystore.data);\n\n  const alg = {\n    name: ALGORITHM,\n    counter: iv,\n    length: 64,\n  };\n  const key = await crypto.subtle.importKey('raw', secret, alg, false, ['decrypt']);\n\n  const ptBuffer = await crypto.subtle.decrypt(alg, key, encryptedText);\n  const decryptedData = new TextDecoder().decode(ptBuffer);\n\n  try {\n    return JSON.parse(decryptedData);\n  } catch {\n    throw new Error('Invalid credentials');\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport type { InputValue } from '@fuel-ts/abi-coder';\nimport { NativeAssetId } from '@fuel-ts/constants';\nimport { hashMessage, hashTransaction } from '@fuel-ts/hasher';\nimport { HDWallet } from '@fuel-ts/hdwallet';\nimport type { AbstractAddress, AbstractPredicate } from '@fuel-ts/interfaces';\nimport { AbstractWallet } from '@fuel-ts/interfaces';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { Mnemonic } from '@fuel-ts/mnemonic';\nimport { ScriptTransactionRequest, transactionRequestify, Provider } from '@fuel-ts/providers';\nimport type {\n  TransactionRequest,\n  TransactionResponse,\n  Coin,\n  TransactionRequestLike,\n  CoinQuantityLike,\n  CoinQuantity,\n  CallResult,\n  BuildPredicateOptions,\n  TransactionResult,\n} from '@fuel-ts/providers';\nimport { Signer } from '@fuel-ts/signer';\nimport { MAX_GAS_PER_TX } from '@fuel-ts/transactions';\n\nimport type { GenerateOptions } from './types/GenerateOptions';\n\n// TODO: import using .env file\nconst FUEL_NETWORK_URL = 'http://127.0.0.1:4000/graphql';\n\nexport default class Wallet extends AbstractWallet {\n  /* default HDWallet path */\n  static defaultPath = \"m/44'/1179993420'/0'/0/0\";\n\n  provider: Provider;\n\n  readonly signer: () => Signer;\n\n  constructor(privateKey: BytesLike, provider: string | Provider = FUEL_NETWORK_URL) {\n    super();\n    const signer = new Signer(privateKey);\n\n    this.signer = () => signer;\n    this.provider = this.connect(provider);\n  }\n\n  get address(): AbstractAddress {\n    return this.signer().address;\n  }\n\n  get privateKey(): string {\n    return this.signer().privateKey;\n  }\n\n  get publicKey(): string {\n    return this.signer().publicKey;\n  }\n\n  /**\n   * Change provider connection\n   */\n  connect(provider: string | Provider) {\n    if (!provider) {\n      throw new Error('Provider is required');\n    } else if (typeof provider === 'string') {\n      this.provider = new Provider(provider);\n    } else {\n      this.provider = provider;\n    }\n    return this.provider;\n  }\n\n  /**\n   * Sign message with wallet instance privateKey\n   *\n   * @param message - Message\n   * @returns string - Signature a ECDSA 64 bytes\n   */\n  signMessage(message: string): string {\n    return this.signer().sign(hashMessage(message));\n  }\n\n  /**\n   * Sign transaction with wallet instance privateKey\n   *\n   * @param transactionRequestLike - TransactionRequestLike\n   * @returns string - Signature a ECDSA 64 bytes\n   */\n  signTransaction(transactionRequestLike: TransactionRequestLike): string {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    const hashedTransaction = hashTransaction(transactionRequest);\n    const signature = this.signer().sign(hashedTransaction);\n\n    return signature;\n  }\n\n  populateTransactionWitnessesSignature(transactionRequestLike: TransactionRequestLike) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n\n    const witnessIndex = transactionRequest.getCoinInputWitnessIndexByOwner(this.address);\n    if (typeof witnessIndex === 'number') {\n      const signedTransaction = this.signTransaction(transactionRequest);\n      transactionRequest.updateWitness(witnessIndex, signedTransaction);\n    }\n\n    return transactionRequest;\n  }\n\n  /**\n   * Returns coins satisfying the spend query.\n   */\n  async getCoinsToSpend(\n    quantities: CoinQuantityLike[],\n    /** Maximum number of coins to return */\n    maxInputs?: number,\n    /** IDs of coins to exclude */\n    excludedIds?: BytesLike[]\n  ): Promise<Coin[]> {\n    return this.provider.getCoinsToSpend(this.address, quantities, maxInputs, excludedIds);\n  }\n\n  /**\n   * Gets coins owned by the wallet address.\n   */\n  async getCoins(): Promise<Coin[]> {\n    const coins = [];\n\n    const pageSize = 9999;\n    let cursor;\n    // eslint-disable-next-line no-unreachable-loop\n    for (;;) {\n      const pageCoins = await this.provider.getCoins(this.address, undefined, {\n        first: pageSize,\n        after: cursor,\n      });\n\n      coins.push(...pageCoins);\n\n      const hasNextPage = pageCoins.length >= pageSize;\n      if (!hasNextPage) {\n        break;\n      }\n\n      // TODO: implement pagination\n      throw new Error(`Wallets with more than ${pageSize} coins are not yet supported`);\n    }\n\n    return coins;\n  }\n\n  /**\n   * Gets balance for the given asset.\n   */\n  async getBalance(assetId: BytesLike = NativeAssetId): Promise<BN> {\n    const amount = await this.provider.getBalance(this.address, assetId);\n    return amount;\n  }\n\n  /**\n   * Gets balances.\n   */\n  async getBalances(): Promise<CoinQuantity[]> {\n    const balances = [];\n\n    const pageSize = 9999;\n    let cursor;\n    // eslint-disable-next-line no-unreachable-loop\n    for (;;) {\n      const pageBalances = await this.provider.getBalances(this.address, {\n        first: pageSize,\n        after: cursor,\n      });\n\n      balances.push(...pageBalances);\n\n      const hasNextPage = pageBalances.length >= pageSize;\n      if (!hasNextPage) {\n        break;\n      }\n\n      // TODO: implement pagination\n      throw new Error(`Wallets with more than ${pageSize} balances are not yet supported`);\n    }\n\n    return balances;\n  }\n\n  /**\n   * Adds coins to the transaction enough to fund it.\n   */\n  async fund<T extends TransactionRequest>(request: T): Promise<void> {\n    const fee = request.calculateFee();\n    const coins = await this.getCoinsToSpend([fee]);\n\n    request.addCoins(coins);\n  }\n\n  /**\n   * Returns coins satisfying the spend query.\n   */\n  async transfer(\n    /** Address of the destination */\n    destination: AbstractAddress,\n    /** Amount of coins */\n    amount: BigNumberish,\n    /** Asset ID of coins */\n    assetId: BytesLike = NativeAssetId,\n    /** Tx Params */\n    txParams: Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'> = {}\n  ): Promise<TransactionResponse> {\n    const params = { gasLimit: MAX_GAS_PER_TX, ...txParams };\n    const request = new ScriptTransactionRequest(params);\n    request.addCoinOutput(destination, amount, assetId);\n    const coins = await this.getCoinsToSpend([[amount, assetId], request.calculateFee()]);\n    request.addCoins(coins);\n\n    return this.sendTransaction(request);\n  }\n\n  /**\n   * Populates witnesses signature and send it to the network using `provider.sendTransaction`.\n   *\n   * @param transactionRequest - TransactionRequest\n   * @returns TransactionResponse\n   */\n  async sendTransaction(\n    transactionRequestLike: TransactionRequestLike\n  ): Promise<TransactionResponse> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n\n    return this.provider.sendTransaction(\n      this.populateTransactionWitnessesSignature(transactionRequest)\n    );\n  }\n\n  /**\n   * Populates witnesses signature and send a call it to the network using `provider.call`.\n   *\n   * @param transactionRequest - TransactionRequest\n   * @returns CallResult\n   */\n  async simulateTransaction(transactionRequestLike: TransactionRequestLike): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n\n    return this.provider.call(this.populateTransactionWitnessesSignature(transactionRequest), {\n      utxoValidation: true,\n    });\n  }\n\n  async buildPredicateTransaction(\n    predicateAddress: AbstractAddress,\n    amountToPredicate: BigNumberish,\n    assetId: BytesLike = NativeAssetId,\n    predicateOptions?: BuildPredicateOptions\n  ): Promise<ScriptTransactionRequest> {\n    const options = {\n      fundTransaction: true,\n      ...predicateOptions,\n    };\n    const request = new ScriptTransactionRequest({\n      gasLimit: MAX_GAS_PER_TX,\n      ...options,\n    });\n\n    // output is locked behind predicate\n    request.addCoinOutput(predicateAddress, amountToPredicate, assetId);\n\n    const requiredCoinQuantities: CoinQuantityLike[] = [];\n    if (options.fundTransaction) {\n      requiredCoinQuantities.push(request.calculateFee());\n    }\n\n    if (requiredCoinQuantities.length) {\n      const coins = await this.getCoinsToSpend(requiredCoinQuantities);\n      request.addCoins(coins);\n    }\n\n    return request;\n  }\n\n  async submitPredicate(\n    predicateAddress: AbstractAddress,\n    amountToPredicate: BigNumberish,\n    assetId: BytesLike = NativeAssetId,\n    options?: BuildPredicateOptions\n  ): Promise<TransactionResult<'success'>> {\n    const request = await this.buildPredicateTransaction(\n      predicateAddress,\n      amountToPredicate,\n      assetId,\n      options\n    );\n    const response = await this.sendTransaction(request);\n    return response.waitForResult();\n  }\n\n  async submitSpendPredicate(\n    predicate: AbstractPredicate,\n    amountToSpend: BigNumberish,\n    predicateData?: InputValue[],\n    assetId: BytesLike = NativeAssetId,\n    options?: BuildPredicateOptions\n  ): Promise<TransactionResult<'success'>> {\n    return this.provider.submitSpendPredicate(\n      predicate,\n      amountToSpend,\n      this.address,\n      predicateData,\n      assetId,\n      options\n    );\n  }\n\n  /**\n   * Generate a new Wallet with a random keyPair\n   *\n   * @param options - GenerateOptions\n   * @returns wallet - Wallet instance\n   */\n  static generate(generateOptions?: GenerateOptions) {\n    const privateKey = Signer.generatePrivateKey(generateOptions?.entropy);\n\n    return new Wallet(privateKey, generateOptions?.provider);\n  }\n\n  /**\n   * Create wallet from a seed\n   */\n  static fromSeed(seed: string, path?: string): Wallet {\n    const hdWallet = HDWallet.fromSeed(seed);\n    const childWallet = hdWallet.derivePath(path || Wallet.defaultPath);\n\n    return new Wallet(<string>childWallet.privateKey);\n  }\n\n  /**\n   * Create wallet from mnemonic phrase\n   */\n  static fromMnemonic(mnemonic: string, path?: string, passphrase?: BytesLike): Wallet {\n    const seed = Mnemonic.mnemonicToSeed(mnemonic, passphrase);\n    const hdWallet = HDWallet.fromSeed(seed);\n    const childWallet = hdWallet.derivePath(path || Wallet.defaultPath);\n\n    return new Wallet(<string>childWallet.privateKey);\n  }\n\n  /**\n   * Create wallet from extended key\n   */\n  static fromExtendedKey(extendedKey: string): Wallet {\n    const hdWallet = HDWallet.fromExtendedKey(extendedKey);\n\n    return new Wallet(<string>hdWallet.privateKey);\n  }\n}\n"],"mappings":"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","names":["init_esm_shims","__esmMin","init_esm_shims","init_esm_shims","init_esm_shims","init_esm_shims","init_esm_shims","arrayify","init_esm_shims","selectedCrypto","selectedStrategy","__require","error","crypto","strategy","init_esm_shims","randomBytes","length","strategy","crypto","init_esm_shims","coinQuantityfy","ScriptTransactionRequest","init_esm_shims","NativeAssetId","hashMessage","hashTransaction","HDWallet","AbstractWallet","Mnemonic","ScriptTransactionRequest","transactionRequestify","Provider","Signer","MAX_GAS_PER_TX","FUEL_NETWORK_URL","_Wallet","privateKey","provider","signer","message","transactionRequestLike","transactionRequest","hashedTransaction","witnessIndex","signedTransaction","quantities","maxInputs","excludedIds","coins","cursor","pageCoins","assetId","balances","pageBalances","request","fee","destination","amount","txParams","params","predicateAddress","amountToPredicate","predicateOptions","options","requiredCoinQuantities","predicate","amountToSpend","predicateData","generateOptions","seed","path","childWallet","mnemonic","passphrase","extendedKey","hdWallet","Wallet","seedWallet","wallet","quantities","genesisWallet","Wallet","randomBytes","coins","request","ScriptTransactionRequest","coinQuantityfy","amount","assetId","generateTestWallet","provider"]}