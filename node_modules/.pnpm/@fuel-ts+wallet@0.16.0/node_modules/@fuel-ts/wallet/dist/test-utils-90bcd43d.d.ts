import { Provider, TransactionRequestLike, TransactionRequest, CoinQuantityLike, Coin, CoinQuantity, TransactionResponse, CallResult, BuildPredicateOptions, ScriptTransactionRequest, TransactionResult } from '@fuel-ts/providers';
import { BytesLike } from '@ethersproject/bytes';
import { InputValue } from '@fuel-ts/abi-coder';
import { AbstractWallet, AbstractAddress, AbstractPredicate } from '@fuel-ts/interfaces';
import { BN, BigNumberish } from '@fuel-ts/math';
import { Signer } from '@fuel-ts/signer';

interface GenerateOptions {
    /** Additional entropy for the random bytes */
    entropy?: BytesLike;
    provider?: string | Provider;
}

declare class Wallet extends AbstractWallet {
    static defaultPath: string;
    provider: Provider;
    readonly signer: () => Signer;
    constructor(privateKey: BytesLike, provider?: string | Provider);
    get address(): AbstractAddress;
    get privateKey(): string;
    get publicKey(): string;
    /**
     * Change provider connection
     */
    connect(provider: string | Provider): Provider;
    /**
     * Sign message with wallet instance privateKey
     *
     * @param message - Message
     * @returns string - Signature a ECDSA 64 bytes
     */
    signMessage(message: string): string;
    /**
     * Sign transaction with wallet instance privateKey
     *
     * @param transactionRequestLike - TransactionRequestLike
     * @returns string - Signature a ECDSA 64 bytes
     */
    signTransaction(transactionRequestLike: TransactionRequestLike): string;
    populateTransactionWitnessesSignature(transactionRequestLike: TransactionRequestLike): TransactionRequest;
    /**
     * Returns coins satisfying the spend query.
     */
    getCoinsToSpend(quantities: CoinQuantityLike[], 
    /** Maximum number of coins to return */
    maxInputs?: number, 
    /** IDs of coins to exclude */
    excludedIds?: BytesLike[]): Promise<Coin[]>;
    /**
     * Gets coins owned by the wallet address.
     */
    getCoins(): Promise<Coin[]>;
    /**
     * Gets balance for the given asset.
     */
    getBalance(assetId?: BytesLike): Promise<BN>;
    /**
     * Gets balances.
     */
    getBalances(): Promise<CoinQuantity[]>;
    /**
     * Adds coins to the transaction enough to fund it.
     */
    fund<T extends TransactionRequest>(request: T): Promise<void>;
    /**
     * Returns coins satisfying the spend query.
     */
    transfer(
    /** Address of the destination */
    destination: AbstractAddress, 
    /** Amount of coins */
    amount: BigNumberish, 
    /** Asset ID of coins */
    assetId?: BytesLike, 
    /** Tx Params */
    txParams?: Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'>): Promise<TransactionResponse>;
    /**
     * Populates witnesses signature and send it to the network using `provider.sendTransaction`.
     *
     * @param transactionRequest - TransactionRequest
     * @returns TransactionResponse
     */
    sendTransaction(transactionRequestLike: TransactionRequestLike): Promise<TransactionResponse>;
    /**
     * Populates witnesses signature and send a call it to the network using `provider.call`.
     *
     * @param transactionRequest - TransactionRequest
     * @returns CallResult
     */
    simulateTransaction(transactionRequestLike: TransactionRequestLike): Promise<CallResult>;
    buildPredicateTransaction(predicateAddress: AbstractAddress, amountToPredicate: BigNumberish, assetId?: BytesLike, predicateOptions?: BuildPredicateOptions): Promise<ScriptTransactionRequest>;
    submitPredicate(predicateAddress: AbstractAddress, amountToPredicate: BigNumberish, assetId?: BytesLike, options?: BuildPredicateOptions): Promise<TransactionResult<'success'>>;
    submitSpendPredicate(predicate: AbstractPredicate, amountToSpend: BigNumberish, predicateData?: InputValue[], assetId?: BytesLike, options?: BuildPredicateOptions): Promise<TransactionResult<'success'>>;
    /**
     * Generate a new Wallet with a random keyPair
     *
     * @param options - GenerateOptions
     * @returns wallet - Wallet instance
     */
    static generate(generateOptions?: GenerateOptions): Wallet;
    /**
     * Create wallet from a seed
     */
    static fromSeed(seed: string, path?: string): Wallet;
    /**
     * Create wallet from mnemonic phrase
     */
    static fromMnemonic(mnemonic: string, path?: string, passphrase?: BytesLike): Wallet;
    /**
     * Create wallet from extended key
     */
    static fromExtendedKey(extendedKey: string): Wallet;
}

declare const seedWallet: (wallet: Wallet, quantities: CoinQuantityLike[]) => Promise<void>;
declare const generateTestWallet: (provider: Provider, quantities?: CoinQuantityLike[]) => Promise<Wallet>;

declare const testUtils_seedWallet: typeof seedWallet;
declare const testUtils_generateTestWallet: typeof generateTestWallet;
declare namespace testUtils {
  export {
    testUtils_seedWallet as seedWallet,
    testUtils_generateTestWallet as generateTestWallet,
  };
}

export { Wallet as W, generateTestWallet as g, seedWallet as s, testUtils as t };
