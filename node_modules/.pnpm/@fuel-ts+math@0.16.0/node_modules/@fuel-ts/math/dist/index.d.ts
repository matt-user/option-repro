import BnJs from 'bn.js';

declare type CompareResult = -1 | 0 | 1;
declare type BNInput = number | string | number[] | Uint8Array | Buffer | BnJs;
interface BNHelper {
    caller(v: BNInput, methodName: string): BN | boolean | CompareResult;
    toHex: (bytesPadding?: number) => string;
    toBytes: (bytesPadding?: number) => Uint8Array;
    toJSON: () => string;
}
interface BNInputOverrides {
    add: (v: BNInput) => BN;
    pow: (v: BNInput) => BN;
    sub: (v: BNInput) => BN;
    div: (v: BNInput) => BN;
    mul: (v: BNInput) => BN;
    mod: (v: BNInput) => BN;
    divRound: (v: BNInput) => BN;
    lt: (v: BNInput) => boolean;
    lte: (v: BNInput) => boolean;
    gt: (v: BNInput) => boolean;
    gte: (v: BNInput) => boolean;
    eq: (v: BNInput) => boolean;
    cmp: (v: BNInput) => CompareResult;
}
interface BNOverrides {
    sqr: () => BN;
    neg: () => BN;
    abs: () => BN;
    toTwos: (width: number) => BN;
    fromTwos: (width: number) => BN;
}
interface BNHiddenTypes {
    mulTo: (num: BN, out: BN) => BN;
    divmod: (num: BNInput, mode?: string, positive?: boolean) => {
        mod: BN;
        div: BN;
    };
}
declare type BNInputOverridesKeys = keyof BNInputOverrides;
declare class BN extends BnJs implements BNInputOverrides, BNHiddenTypes, BNHelper, BNOverrides {
    constructor(value: BNInput, base?: number | 'hex', endian?: BnJs.Endianness);
    toString(base?: number | 'hex', length?: number): string;
    toHex(bytesPadding?: number): string;
    toBytes(bytesPadding?: number): Uint8Array;
    toJSON(): string;
    add(v: BNInput): BN;
    pow(v: BNInput): BN;
    sub(v: BNInput): BN;
    div(v: BNInput): BN;
    mul(v: BNInput): BN;
    mod(v: BNInput): BN;
    divRound(v: BNInput): BN;
    lt(v: BNInput): boolean;
    lte(v: BNInput): boolean;
    gt(v: BNInput): boolean;
    gte(v: BNInput): boolean;
    eq(v: BNInput): boolean;
    cmp(v: BNInput): CompareResult;
    sqr(): BN;
    neg(): BN;
    abs(): BN;
    toTwos(width: number): BN;
    fromTwos(width: number): BN;
    caller(v: BNInput, methodName: BNInputOverridesKeys): BN | boolean | CompareResult;
    clone(): BN;
    mulTo(num: BN, out: BN): BN;
    egcd(p: BnJs): {
        a: BN;
        b: BN;
        gcd: BN;
    };
    divmod(num: BNInput, mode?: string, positive?: boolean): {
        mod: BN;
        div: BN;
    };
}
declare const bn: (value: BNInput, base?: number | 'hex', endian?: BnJs.Endianness) => BN;

/**
 * From: https://github.dev/ethers-io/ethers.js/blob/9ca3dc557de8d1556096ea4140316e7f7711a0f3/packages/math/src.ts/convert.ts
 */

declare function toNumber(value: BNInput): number;
declare function toHex(value: BNInput, bytesPadding?: number): string;
declare function toBytes(value: BNInput, bytesPadding?: number): Uint8Array;

declare type BigNumberish = string | number | BN;

declare function max(...numbers: Array<BigNumberish>): BN;
declare function multiply(...numbers: Array<BigNumberish>): BN;

export { BN, BNInput, BigNumberish, bn, max, multiply, toBytes, toHex, toNumber };
